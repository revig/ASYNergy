{"version":3,"sources":["../src/util/walkDOM.js","../src/util/debounce.js","../src/util/asynDirectives.js","../src/action/index.js","../src/action/event.js","../src/util/dispatch.js","../src/MessageBus.js","../src/HookManager.js","../src/Store.js","../src/DirectiveManager.js","../src/action/deferred-model.js","../src/action/Deferred.js","../src/connection/index.js","../src/dom/dom.js","../src/action/handler.js","../src/action/model.js","../src/Message.js","../src/agent/index.js","../src/init_tasks.js","../src/util/index.js","../src/agent/DisableForms.js","../src/agent/SyncBrowserHistory.js","../src/index.js","../src/agent/LoadingStates.js","../src/agent/Polling.js"],"names":["walkDOM","rootEl","callback","node","firstElementChild","nextElementSibling","debounce","func","wait","immediate","timeout","context","this","args","arguments","later","apply","callNow","clearTimeout","setTimeout","asynDirectives","el","DirectiveManager","[object Object]","directives","extractTypeModifiersAndValue","type","map","directive","includes","has","find","Array","from","getAttributeNames","filter","name","match","RegExp","modifiers","replace","split","Directive","fullName","eventContext","lcFunc","emitEvent","isEmitEvent","theBool","value","getAttribute","lcFunction","fullVal","search","modelValue","undefined","innerText","handler","parseOutHandlerAndParams","params","defaultDuration","durationInMilliSeconds","durationInMilliSecondsString","mod","durationInSecondsString","Number","rawHandler","handlerAndParamString","Function","fallback","time","modelDebounceCallbacks","callbackRegister","push","e","Action","skipWatcher","updateQueue","EventAction","modelAttrVal","modelVal","isCustomEvent","super","payload","btoa","encodeURIComponent","event","JSON","stringify","dispatch","eventName","options","theHandler","CustomEvent","addEventListener","dispatchEvent","MessageBus","listeners","forEach","Object","keys","HookManager","availableHooks","bus","register","call","store","csrf","transmissionEls","mutables","mutableElem","url","asynergyIsInBackground","asynergyIsOffline","hooks","agents","nodesSetToDisabled","nodesSetToReadOnly","mutableIncludesModel","key","agent","length","agentID","agentsLength","i","index","removeAgent","agentsListeningForEvent","addAction","theAgents","directiveParams","handlerName","on","paramsA","modelParams","selectValues","isArray","toString","checked","detail","option","indexOf","setAttribute","removeAttribute","tearDown","splice","listenerType","modelValueKey","transmissionElIsCheckbox","transmissionElIsRadio","transmissionElIsMutable","mutable","isChecked","transmissionElsData","tagName","innerHTML","modelData","theNode","disabled","readOnly","mutablesData","mutableAttrVal","mutableInnerHTML","id","DeferredModelAction","Deferred","deferredActions","deferredActionsData","payloadDeferred","action","hasOwnProperty","actionData","exec","substr","Connection","URL","updateEl","modelEl","ajax","completed_callback","headers","asynPayload","actionType","modelSyncTimeout","reregisterEvLis","message","receiveMessage","responseObj","fetchedResponse","connection","callHook","values","asynergyResponse","respItem","mutableVal","updated","updateMutablesByID","updateMutablesByAttrVal","syncModels","location","ASYNergy","reregisterEventListeners","msg","clearDisabledReadOnlyNodesArrays","updates","tokenName","token","mutabelsData","deferredModelData","fetch","method","Content-Type","X-Requested-With","Accept","X-ASYNergy","Referer","window","href","body","then","response","ok","text","parse","onMessage","handleResponse","catch","error","console","warn","mutableID","theID","document","getElementById","nodeName","attrValFragments","attrValPrefix","syncModelID","modelID","timer","model","mutableEl","timeOut","DOM","allModelElementsInside","root","querySelectorAll","getByAttributeAndValue","attribute","querySelector","hasAttribute","hasFocus","activeElement","isInput","toUpperCase","isTextInput","modelName","get","mergeCheckboxValueIntoArray","multiple","getSelectValues","arrayValue","concat","item","modelString","data","toLowerCase","setInputValue","valueFound","val","updateSelect","selected","arrayWrappedValue","HandlerAction","ModelAction","Message","update","Agent","postValue","messageInTransit","tearDownCallbacks","scopedListeners","fireMessage","entries","unshift","sendMessage","storeResponse","callbackWhenNewComponentIsEncountered","isSameNode","teardownCallback","nodeInitializer","reregisterEvl","isAgent","all","directiveVal","compoundAttrVal","attr","modelAttr","modelElem","attachModelListener","attachDomListener","theAgent","eventType","isLazy","hasDebounceModifier","initConnection","addAgent","condition","modelSyncDebounce","debounceIf","target","documentMode","valueFromInput","durationOr","addEmitEvent","addListenerForTeardown","removeEventListener","test","navigator","userAgent","animationName","Event","bubbles","attachListener","selectedSystemKeyModifiers","keyCode","modifier","Boolean","subject","kebabCase","callAfterModelDebounce","setEventContext","preventAndStop","debouncedHandler","preventDefault","stopPropagation","attrVal","escapedStr","str","x","cleanupStackByAgentId","cleanup","shift","ASYNergyStateManager","updateState","state","currentState","stateArray","toStateArray","fullstateObject","assign","history","charAt","slice","capitalize","decodeURI","replaceAll","storeInSession","asynergy","ASYNergyState","getFromSession","replayResponses","missingState","Date","getTime","stringifiedValue","tryToStoreInSession","sessionStorage","setItem","code","oldestTimestamp","sort","removeItem","getItem","items","signature","targetItem","existingIndex","findIndex","pushItemInProperOrder","findAgentBySignature","getAgentsByID","appVersion","version","theURL","registerHook","emit","tearDownAgents","initialize","bodyEl","hidden","initializedPath","agentIdsThatAreWritingToHistoryState","Set","clearState","browserHistoryOn","responseItemNum","mutablesItem","replaceState","add","replaying","effects","pushState","doReplayResponse","SyncBrowserHistory","targetedLoadingElsByAction","genericLoadingEls","currentlyActiveLoadingEls","currentlyActiveUploadLoadingEls","missing","generateSignatureFromHandlerAndParams","modelActions","reduce","fullAction","part","flat","walk","contains","addDisabledNode","addReadOnlyNode","intervalId","interval","setInterval","isConnected","Math","random","bounding","getBoundingClientRect","top","innerHeight","documentElement","clientHeight","left","innerWidth","clientWidth","bottom","right","inViewport","fireActionOnInterval","clearInterval","__asynergy_polling_interval"],"mappings":"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","sourcesContent":["export function walkDOM(rootEl, callback) {\n    if (callback(rootEl) === false) {\n        return;\n    }\n\n    let node = rootEl.firstElementChild;\n\n    while (node) {\n        walkDOM(node, callback);\n        node = node.nextElementSibling;\n    }\n}\n","export function debounce(func, wait, immediate) {\n    var timeout;\n    return function () {\n        var context = this;\n        var args = arguments;\n        var later = function () {\n            timeout = null;\n            if (!immediate) {\n                func.apply(context, args);\n            }\n        };\n\n        var callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n            func.apply(context, args);\n        }\n    };\n}\n","export function asynDirectives(el) {\n    return new DirectiveManager(el);\n}\n\nclass DirectiveManager {\n    constructor(el) {\n        this.el = el;\n        this.directives = this.extractTypeModifiersAndValue();\n    }\n\n    all() {\n        return this.directives;\n    }\n\n    has(type) {\n        return this.directives.map(directive => directive.type).includes(type);\n    }\n\n    missing(type) {\n        return !this.has(type);\n    }\n\n    get(type) {\n        return this.directives.find(directive => directive.type === type);\n    }\n\n    extractTypeModifiersAndValue() {\n        return Array.from(this.el.getAttributeNames()\n\n        // FILTER ONLY THE ASYNergy DIRECTIVES\n        .filter(name => name.match(new RegExp('asyn:')))\n\n        // PARSE OUT THE TYPE, MODIFIERS, AND VALUE FROM IT\n        .map(name => {\n                const [type, ...modifiers] = name.replace(new RegExp('asyn:'), '').split('.');\n\n                return new Directive(type, modifiers, name, this.el);\n            }));\n    }\n}\n\nclass Directive {\n    constructor(type, modifiers, fullName, el) {\n        this.type = type;\n        this.modifiers = modifiers;\n        this.fullName = fullName;\n        this.el = el;\n        this.eventContext;\n        this.lcFunc = null;\n        this.emitEvent = false;\n    }\n\n    setEventContext(context) {\n        this.eventContext = context;\n    }\n    \n    get isEmitEvent() {\n      return emitEvent;\n    }\n    \n    set isEmitEvent(theBool) {\n      if (typeof theBool == \"boolean\") {\n        this.emitEvent = theBool;\n      }\n    }\n\n    get value() {\n        return this.el.getAttribute(this.fullName);\n    }\n    \n    get lcFunction() {\n      if (this.fullName === \"asyn:mutable\") {\n        const fullVal = this.el.getAttribute(this.fullName);\n\n        // GET LIVECODE FUNCTION TO BE CALLED\n        const pos = fullVal.search(/\\./);\n        if (pos !== -1) {\n            this.lcFunc = fullVal.split(\".\")[1];\n        }\n      }\n      return this.lcFunc;\n    }\n    \n    get modelValue() {\n      return this.el.value !== undefined ? this.el.value : this.el.innerText;\n    }\n\n    get handler() {\n      const { handler } = this.parseOutHandlerAndParams(this.value);\n      return handler;\n    }\n\n    get params() {\n      const { params } = this.parseOutHandlerAndParams(this.value);\n\n        return params;\n    }\n\n    durationOr(defaultDuration) {\n        let durationInMilliSeconds;\n        const durationInMilliSecondsString = this.modifiers.find(mod => mod.match(/([0-9]+)ms/));\n        const durationInSecondsString = this.modifiers.find(mod => mod.match(/([0-9]+)s/));\n\n        if (durationInMilliSecondsString) {\n            durationInMilliSeconds = Number(durationInMilliSecondsString.replace('ms', ''));\n        } else if (durationInSecondsString) {\n            durationInMilliSeconds = Number(durationInSecondsString.replace('s', '')) * 1000;\n        }\n\n        return durationInMilliSeconds || defaultDuration;\n    }\n\n    parseOutHandlerAndParams(rawHandler) {\n      let handler = rawHandler;\n        let params = [];\n        const handlerAndParamString = handler.match(/(.*?)\\((.*)\\)/s);\n\n        if (handlerAndParamString) {\n          handler = handlerAndParamString[1];\n\n            // USE A FUNCTION THAT RETURNS IT'S ARGUMENTS TO PARSE AND EVAL ALL PARAMS\n            // THIS \"$EVENT\" IS FOR USE INSIDE THE ASYNergy EVENT HANDLER\n            // ---------------- $event NOT USED ----------------------- //\n            let func = new Function('$event', `return (function () {\n              for (var l=arguments.length, p=new Array(l), k=0; k<l; k++) {\n                p[k] = arguments[k];\n              }\n              return [].concat(p);\n            })(${handlerAndParamString[2]})`);\n\n            params = func(this.eventContext);\n        }\n        return { handler, params };\n    }\n\n    cardinalDirectionOr(fallback = 'right') {\n        if (this.modifiers.includes('up')) {\n            return 'up';\n        }\n        if (this.modifiers.includes('down')) {\n            return 'down';\n        }\n        if (this.modifiers.includes('left')) {\n            return 'left';\n        }\n        if (this.modifiers.includes('right')) {\n            return 'right';\n        }\n        return fallback;\n    }\n\n    modelSyncDebounce(callback, time) {\n        // Prepare yourself for what's happening here.\n        // Any text input with asyn:model on it should be \"debounced\" by ~150ms by default.\n        // We can't use a simple debounce function because we need a way to clear all the pending\n        // debounces if a user submits a form or performs some other action.\n        // This is a modified debounce function that acts just like a debounce, except it stores\n        // the pending callbacks in a global property so we can \"clear them\" on command instead\n        // of waiting for their setTimeouts to expire.\n        if (!this.modelDebounceCallbacks) {\n            this.modelDebounceCallbacks = [];\n        }\n\n        // This is a \"null\" callback. Each asyn:model will register one of these upon initialization.\n        let callbackRegister = { callback: () => { } };\n\n        this.modelDebounceCallbacks.push(callbackRegister);\n\n        // This is a normal \"timeout\" for a debounce function.\n        var timeout;\n\n        return e => {\n            clearTimeout(timeout);\n\n            timeout = setTimeout(() => {\n                callback(e);\n                timeout = undefined;\n\n                // Because we just called the callback, let's return the\n                // callback register to it's normal \"null\" state.\n                callbackRegister.callback = () => { };\n            }, time);\n\n            // Register the current callback in the register as a kind-of \"escape-hatch\".\n            callbackRegister.callback = () => {\n                clearTimeout(timeout);\n                callback(e);\n            };\n        };\n    }\n}\n","export default class {\n    constructor(el, skipWatcher = false) {\n        this.el = el;\n        this.skipWatcher = skipWatcher;\n        this.updateQueue = [];\n    }\n}\n","import Action from '.';\n\nexport default class extends Action {\n    constructor(modelAttrVal, params, modelVal, isCustomEvent, el) {\n      super(el);\n\n      this.isCustomEvent = isCustomEvent;\n      this.type = 'fireEvent';\n      this.name = modelAttrVal;\n        this.payload = {\n            modelAttrVal,\n            params,\n            modelVal\n        };\n    }\n\n    // Overriding toId() becuase some EventActions don't have an \"el\"\n    toId() {\n        return btoa(encodeURIComponent(this.type, this.payload.event, JSON.stringify(this.payload.params)));\n    }\n}\n","export function dispatch(el, eventName, options, theHandler) {\n    const event = new CustomEvent(eventName, options);\n    el.addEventListener(eventName, theHandler);\n    el.dispatchEvent(event);\n}","\nexport default class MessageBus {\n    constructor() {\n        this.listeners = {};\n    }\n\n    register(name, callback) {\n        if (!this.listeners[name]) {\n            this.listeners[name] = [];\n        }\n\n        this.listeners[name].push(callback);\n    }\n\n    call(name, ...params) {\n        (this.listeners[name] || []).forEach(callback => {\n            callback(...params);\n        });\n    }\n\n    has(name) {\n        return Object.keys(this.listeners).includes(name);\n    }\n}\n","import MessageBus from './MessageBus';\n\nexport default {\n\tavailableHooks: [\n\t\t/**\n\t\t* Public Hooks\n\t\t*/\n\t\t'agent.initialized',\n\t\t'element.initialized',\n\t\t'element.updating',\n\t\t'element.updated',\n\t\t'element.removed',\n\t\t'message.sent',\n\t\t'message.failed',\n\t\t'message.received',\n\t\t'message.processed',\n\t\t'allMessages.processed',\n\t\t'request',\n\n\t\t/**\n\t\t* Private Hooks\n\t\t*/\n\t\t'interceptAsynModelSetValue',\n\t\t'interceptAsynModelAttachListener',\n\t\t'beforeReplaceState',\n\t\t'beforePushState'\n\t],\n\n  bus: new MessageBus(),\n\n  register(name, callback) {\n    if (!this.availableHooks.includes(name)) {\n      throw `ASYNergy: Referencing unknown hook: [${name}]`;\n    }\n\n    this.bus.register(name, callback);\n  },\n\n  call(name, ...params) {\n    this.bus.call(name, ...params);\n  }\n};\n","import EventAction from './action/event';  // ----------------------- temp test events\nimport { dispatch } from './util/dispatch'; // ------------------------------ temp test events\nimport HookManager from './HookManager';\nimport MessageBus from './MessageBus'; // -------- temp test events\nimport DirectiveManager from './DirectiveManager';\n// import Agent from './agent/index';\n\nconst store = {\n    csrf: {},\n    transmissionEls: [],\n    mutables: [],\n    directives: DirectiveManager,\n    asynergyIsInBackground: false,\n    asynergyIsOffline: false,\n    hooks: HookManager,\n    agents: [],\n    listeners: new MessageBus(),\n    nodesSetToDisabled: [],\n    nodesSetToReadOnly: [],\n    mutableIncludesModel: false,\n\n    theAgents() {\n      return Object.keys(this.agents).map(key => {\n        return this.agents[key];\n      });\n    },\n\n    registerHook(name, callback) {\n        this.hooks.register(name, callback);\n    },\n\n    callHook(name, ...params) {\n        this.hooks.call(name, ...params);\n    },\n\n    addAgent(agent) {\n        this.agents.push(agent);\n        return this.agents[this.agents.length - 1];\n    },\n\n    getAgentsByID(agentID) {\n      return this.agents.filter(agent => {\n        return agent.agentID === agentID;\n      });\n    },\n\n    tearDownAgents() {\n        let agentsLength = this.agents.length;\n        for (let i = 0; i < agentsLength; i++) {\n            let index = this.agents.length - 1;\n            this.removeAgent(this.agents[index], index);\n        }\n    },\n\n    emit(event, ...params) {\n      this.listeners.call(event, ...params);\n        this.agentsListeningForEvent(event).forEach(agent => {\n          agent.addAction(new EventAction(event, params));\n        });\n    },\n\n    agentsListeningForEvent(event) {\n        return this.theAgents().filter(agent => {\n          return agent.listeners.includes(event);\n        });\n    },\n    \n    addEmitEvent(el, directiveParams, handlerName, handler) {\n      let options = {};\n      const eventHandler = (...paramsA) => {\n        \n        const modelParams = [];\n        modelParams[0] = [];\n        let selectValues;\n        \n        if (paramsA !== undefined & paramsA.length !== 0) {\n          if (paramsA[0] !== undefined & paramsA[0].length !== 0) {\n            modelParams[0] = paramsA[0].split(',');\n          }\n\n          if (Array.isArray(paramsA) & (modelParams[0].toString() === directiveParams.toString())) {\n            \n            switch(el.type) {             \n              case 'text':\n                if (paramsA[1] !== undefined) {\n                  el.value = paramsA[1];\n                }\n\n                break;\n              \n              case 'checkbox':\n                if (paramsA[2] !== undefined) {\n                  el.checked = paramsA[2];\n                }\n                \n                break;\n\t\t\t\t\t\t\n              case 'radio':\n                if (paramsA[2] !== undefined) {\n                  el.checked = paramsA[2];\n                }\n                \n                break;\n                \n              case 'select-multiple':\n                if (paramsA[1] !== undefined) {\n                  selectValues = paramsA[1].split(',');\n                }\n                \n                if (selectValues !== undefined) {\n                  options.detail = selectValues;\n                }\n\n                for (const option of el.options) {\n                  if (selectValues.indexOf(option.value) !== -1) {\n                    option.setAttribute('selected', 'selected');\n                  } else {\n                    option.removeAttribute('selected');\n                  }\n                }\n                \n                break;\n\n              case 'submit':\n                if ( paramsA[1] !== undefined) {\n                  const modelValue = paramsA[1].split(',');\n                \n                  if (modelValue !== undefined) {\n                    options.detail = modelValue;\n                  }\n                }\n                \n                break;\n            }\n\n            dispatch(el, handlerName, options, handler);\n          }\n        } else { // if (paramsA !== undefined)\n          dispatch(el, handlerName, options, handler);\n        }\n      };\n      this.on(handlerName, eventHandler);\n    },\n\n    on(event, callback) {\n      this.listeners.register(event, callback);\n    },\n\n    removeAgent(agent, index) {\n        // Remove event listeners attached to the DOM.\n        agent.tearDown();\n        // Remove the component from the store.\n        // delete this.agents[index];\n        this.agents.splice(index, 1);\n    },\n\n      transmissionElsData(payload, listenerType, modelValueKey) {\n          if (this.transmissionEls[0] !== undefined) {\n            let index;\n            for (index = 0; index < this.transmissionEls.length; index++) {\n              if (this.transmissionEls[index].getAttribute('asyn:transmit') !== null) {\n\n                const transmissionElIsCheckbox = this.transmissionEls[index].type === 'checkbox';\n\t\t\t\t\t\t\tconst transmissionElIsRadio = this.transmissionEls[index].type === 'radio';\n                const transmissionElIsMutable = this.transmissionEls[index].mutable >= 0;\n\t\t\t\t\t\t\t\n                if (transmissionElIsCheckbox) {\n                    const isChecked = this.transmissionEls[index].checked;\n                    payload.transmissionElsData[this.transmissionEls[index].getAttribute('asyn:transmit')] = isChecked ? this.transmissionEls[index].value : 'false';\n\t\t\t\t\t\t\t\n\t              } else if (transmissionElIsRadio) {\n\t                  const isChecked = this.transmissionEls[index].checked;\n\t                  if (isChecked) {\n\t                      payload.transmissionElsData[this.transmissionEls[index].getAttribute('asyn:transmit')] = this.transmissionEls[index].value;\n\t                  }\n\t\t\t\t\t\t\t\n                } else {\n                    payload.transmissionElsData[this.transmissionEls[index].getAttribute('asyn:transmit')] = (this.transmissionEls[index].tagName === 'INPUT') || (this.transmissionEls[index].tagName === 'TEXTAREA') || (this.transmissionEls[index].tagName === 'SELECT') ? this.transmissionEls[index].value : this.transmissionEls[index].innerHTML;\n\n                    // REPLACE CHECKBOX MODEL VALUE WITH MUTABLE ELEMENT DATA\n                    if (listenerType === 'checkbox' && transmissionElIsMutable) {\n                        payload.modelData[modelValueKey] = this.transmissionEls[index].innerHTML;\n                    }\n\n                }\n              }\n            }\n        }\n        return payload;\n    },\n\n    addDisabledNode(theNode) {\n      this.nodesSetToDisabled.push(theNode);\n    },\n\n    addReadOnlyNode(theNode) {\n      this.nodesSetToReadOnly.push(theNode);\n    },\n\n    clearDisabledReadOnlyNodesArrays() {\n      let index;\n\n      for (index = 0; index < this.nodesSetToDisabled.length; index++) {\n        this.nodesSetToDisabled[index].disabled = false;\n      }\n      this.nodesSetToDisabled.length = 0;\n\n      for (index = 0; index < this.nodesSetToReadOnly.length; index++) {\n        this.nodesSetToReadOnly[index].readOnly = false;\n      }\n      this.nodesSetToReadOnly.length = 0;\n    },\n\n    mutabelsData(payload) {\n      if (this.mutables[0] !== undefined) {\n        let index;\n        for (index = 0; index < this.mutables.length; index++) {\n\n          payload.mutablesData[index] = {};\n          payload.mutablesData[index].mutableAttrVal = this.mutables[index].value;\n          payload.mutablesData[index].el = this.mutables[index].el;\n          payload.mutablesData[index].mutableInnerHTML = this.mutables[index].el.innerHTML;\n          payload.mutablesData[index].lcFunc = this.mutables[index].lcFunc;\n          payload.mutablesData[index].id = this.mutables[index].el.id;\n        }\n      } else {\n        payload.mutablesData = null;\n      }\n      \n      return payload;\n    }\n};\n\nexport default store;\n","import MessageBus from './MessageBus';\n\nexport default {\n    directives: new MessageBus(),\n\n    register(name, callback) {\n        if (this.has(name)) {\n            throw `ASYNergy: Directive already registered: [${name}]`;\n        }\n\n        this.directives.register(name, callback);\n    },\n\n    call(name, el, directive, mutableElem, url) {\n        this.directives.call(name, el, directive, mutableElem, url);\n    },\n\n    has(name) {\n        return this.directives.has(name);\n    }\n};\n","import Action from '.';\n\nexport default class extends Action {\n    constructor(modelAttrVal, params, modelVal, isCustomEvent, el, skipWatcher = false) {\n        super(el, skipWatcher);\n\n        this.isCustomEvent = isCustomEvent;\n        this.type = 'syncInput';\n        this.name = modelAttrVal;\n        this.payload = {\n            modelAttrVal,\n            params,\n            modelVal\n        };\n    }\n}\n","import DeferredModelAction from './deferred-model';\n\nexport default {\n  deferredActions: {},\n\n  addAction(name, value, el) {\n    if (!this.deferredActions[name]) {\n      new DeferredModelAction(name, value, el);\n      this.deferredActions[name] = [];\n    }\n\n    this.deferredActions[name].push(value);\n    this.deferredActions[name].push(el);\n  },\n\n  get deferredActionsData() {\n    let payloadDeferred = {};\n\n    if (this.deferredActions.length !== 0) {\n\n      // GET NAMES AND VALUES OF DEFERRED ACTIONS\n      for (let action in this.deferredActions) {\n        if (this.deferredActions.hasOwnProperty(action)) {\n          let actionData = this.deferredActions[action];\n\n          // actionData[0], IS THE INITIAL VALUE actionData[1] IS THE ELEMENT\n          // this.asynPayload[action] = actionData[1].value;\n          // USE THE ACTION SUFFIX AS PAYLOAD KEY\n\n          // REGULAR EXPRESSION (?<=(\\.)).+$ DOES NOT WORK WITH WEBKIT\n          // DUE TO LOOKBEHIND. WE USE (?:(\\.)).+$ AND STRIP THE FIRST\n          // CHARACTER, A DOT IN THIS CASE\n          // const actionSuffix = /(?<=(\\.)).+$/.exec(action);\n          // this.asynPayload[actionSuffix[0]] = actionData[1].value;\n          const actionExecResult = /(?:(\\.)).+$/.exec(action);\n          const actionSuffix = actionExecResult[0].substr(1);\n          payloadDeferred[actionSuffix] = actionData[1].value;\n        }\n      }\n    }\n    return payloadDeferred;\n  }\n};\n","import store from '../Store';\nimport Deferred from '../action/Deferred';\n\nexport default class Connection {\n\tconstructor(URL, updateEl, modelAttrVal, modelEl, event) {\n\t\tthis.url = URL;\n\t\tthis.updateEl = updateEl;\n\t\t// this.postKey = postKey;\n\t\tthis.modelAttrVal = modelAttrVal;\n\t\tthis.event = event;\n\t\tthis.action = this.ajax;\n\t\tthis.callback = this.completed_callback;\n\t\tthis.headers = {};\n\t\tthis.options = {};\n\t\tthis.options.headers = this.headers;\n\t\tthis.asynPayload = {};\n\t\tthis.mutablesData = [];\n\t\tthis.modelEl = modelEl;\n\t\tthis.actionType = '';\n\t\tthis.modelSyncTimeout = 1000;\n\t\tthis.isCustomEvent = undefined;\n\t\tthis.reregisterEvLis = false;\n\t}\n\t\t\n\t\t\n    onMessage(message, payload) {\n      message.agent.receiveMessage(message, payload);\n    }\n    \n    handleResponse(event, agent, responseObj, fetchedResponse) {\n      if (fetchedResponse !== true) {\n        this.event = event;\n        this.updateEl = agent.connection.updateEl;\n      };\n      \n      store.callHook('element.updating', this.updateEl, agent, event);\n\n      Object.values(responseObj.asynergyResponse).forEach(respItem => {\n        if (respItem.url !== undefined) {\n          location = respItem.url;\n          return;\n        }\n\n        if ((respItem.mutableVal === null) || (typeof(respItem.mutableVal) === \"object\") &&\n        (Object.keys(respItem.mutableVal).length === 0)) {\n          respItem.mutableVal = \"\";\n        }\n\n        if ((typeof respItem.mutableVal === \"string\") && (respItem.mutableVal.search(/asyn:/)) !== -1) {\n          this.reregisterEvLis = true;\n        }\n\n        this.updateEl.updated = 0;\n\n        this.updateMutablesByID(respItem);\n                \n        this.updateMutablesByAttrVal(respItem);\n                \n        if (this.updateEl.updated === 0) {\n          this.updateEl.innerHTML = respItem.mutableVal;\n        }\n                  \n        store.callHook('element.updated', this.updateEl, agent, this.event);\n                \n        this.syncModels(respItem);\n\n        store.callHook('message.processed', this.updateEl, agent, this.event);\n\n      });\n\n      if (this.reregisterEvLis === true) {\n        ASYNergy.reregisterEventListeners();\n      };\n\n    }\n\t\t\n\n    // FETCH COMPLETED ACTION //\n    completed_callback(msg) {\n\t\t\tstore.clearDisabledReadOnlyNodesArrays();\n\t\t\tstore.callHook('allMessages.processed', msg);\n    }\n    \n\n    ajax(message) {\n        const payload = message.payload();\n        const modelVal = payload.updates[0].payload.modelVal;\n        const listenerType = message.agent.el.type;\n        const modelParams = payload.updates[0].payload.params;\n\n        this.asynPayload = {};\n\n        this.asynPayload.modelData = {'modelAttrVal': this.modelAttrVal, 'modelVal': modelVal, 'modelParams': modelParams};\n\n        // CSRF\n        if (store.csrf.tokenName !== undefined && store.csrf.token !== '') {\n            this.asynPayload[store.csrf.tokenName] = store.csrf.token;\n        }\n        \n        // GET MUTABLE ELEMENTS DATA\n        this.asynPayload.mutablesData = [];\n        this.asynPayload = store.mutabelsData(this.asynPayload);\n        this.mutablesData = this.asynPayload.mutablesData;\n        \n        if (this.mutablesData === null) {\n          console.warn(\"Missing data of any mutable element!\");\n          return;\n        }\n        \n        if (this.updateEl === null) {\n          this.updateEl = this.mutablesData[0].el;\n        }\n        let index;\n\n        var mutableAttrVal = this.mutablesData[0].mutableAttrVal;\n\n        // GET TRANSMISSION ELEMENTS DATA\n        this.asynPayload.transmissionElsData = {};\n        this.asynPayload = store.transmissionElsData(this.asynPayload, listenerType, 'modelVal');\n\n        // GET DEFERRED MODEL ACTIONS\n        this.asynPayload.deferredModelData = Deferred.deferredActionsData;\n\n        this.asynPayload.actionType = message.updateQueue[0].type;\n        this.actionType = this.asynPayload.actionType;\n        \n        this.asynPayload.isCustomEvent = message.updateQueue[0].isCustomEvent;\n        this.isCustomEvent = this.asynPayload.isCustomEvent;\n\t\t\t\t\n\t\t\t store.callHook('request', this.options, this.mutablesData, this.asynPayload.modelData);\n\n        this.asynPayload = JSON.stringify(this.asynPayload);\n\n\n        fetch(this.url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'X-Requested-With': 'XMLHttpRequest',\n                'Accept': 'text/html, application/xhtml+xml',\n                'X-ASYNergy': true,\n\n                // SET CUSTOM HEADERS\n                ...(this.options.headers),\n\n                // WE'LL SET THIS EXPLICITLY TO MITIGATE POTENTIAL\n                // INTERFERENCE FROM AD-BLOCKERS/ETC.\n                'Referer': window.location.href\n            },\n            body: this.asynPayload\n        })   \n        .then(response => {\n            if (response.ok) {\n\n              response.text().then(response => {\n\n                const responseObj = JSON.parse(response);\n\n                this.onMessage(message, responseObj);\n                \n                const fetchedResponse = true;\n                \n                this.handleResponse(event, message.agent, responseObj, fetchedResponse);\n\n                this.callback(message);\n\n              });\n            }\n        })\n        \n        .catch((error) => {\n            console.error(error);\n          });\n    }\n    \n    // IF THE RESPONSE INCLUDES IDs OF MUTABLE ELEMENTS\n    // UPDATE ALL APPROPRIATE ELEMENTS\n    updateMutablesByID (responseObj) {\n      if ((responseObj.mutableID !== \"\") && \n      (responseObj.mutableID !== null)) {\n        const mutableID = responseObj.mutableID;\n        \n        if (typeof(mutableID) === \"object\") {\n          Object.values(mutableID).forEach(theID => {\n            this.updateEl = document.getElementById(`${theID}`);\n\n            this.updateEl.nodeName === \"INPUT\" ? this.updateEl.value = responseObj.mutableVal : this.updateEl.innerHTML = responseObj.mutableVal;\n            this.updateEl.updated = 1;\n          });\n        } else {\n          this.updateEl = document.getElementById(`${mutableID}`);\n          this.updateEl.nodeName === \"INPUT\" ? this.updateEl.value = responseObj.mutableVal : this.updateEl.innerHTML = responseObj.mutableVal;\n\n          this.updateEl.updated = 1;\n        }\n      }\n    }\n\n    // IF MULTIPLE MUTABLE ELEMENTS ARE SPECIFIED BY MUTABLE\n    // ATTRIBUTE VALUES IN THE RESPONSE, UPDATE ALL MUTABLE\n    // ELEMENTS THAT HAVE THE APPROPRIATE MUTABLE ATTRIBUTE VALUE\n    updateMutablesByAttrVal(responseObj) {\n      if (responseObj.mutableAttrVal !== \"\") {\n        if (this.mutablesData.length > 0) {\n          let attrValFragments = [];\n          let attrValPrefix = '';\n          this.mutablesData.forEach(mutable => {\n            const compoundAttrVal = mutable.mutableAttrVal.search(/[.]/);\n            if (compoundAttrVal !== -1) {\n              attrValFragments = /^.+(?=(\\.))/.exec(mutable.mutableAttrVal);\n              attrValPrefix = attrValFragments[0];\n            }\n\n            if ((mutable.mutableAttrVal === responseObj.mutableAttrVal) || \n                (mutable.mutableAttrVal === attrValPrefix) || \n                (Object.values(responseObj.mutableAttrVal).indexOf(mutable.mutableAttrVal) > -1)) {\n              this.updateEl = mutable.el;\n\n              this.updateEl.nodeName === \"INPUT\" ? this.updateEl.value = responseObj.mutableVal : this.updateEl.innerHTML = responseObj.mutableVal;\n              this.updateEl.updated = 1;\n            }\n            \n          });\n        }\n      }\n    }\n    \n    // SYNCHRONIZE ANY MODEL TO THE DATA OF THE MUTABLE ELEMENT\n    syncModels(responseObj) {\n      if ((responseObj.syncModelID !== \"\") && \n      (responseObj.syncModelID !== null)) {\n        let modelID = responseObj.syncModelID;\n\n        if (this.actionType === \"syncInput\") {\n          // SYNCHRONIZING NEEDS A DELAY, OTHERWISE SOME INPUT MAY BE LOST\n          let timer;\n          const model = document.getElementById(`${modelID}`);\n          const mutableEl = this.updateEl;\n          const timeOut = this.modelSyncTimeout;\n\n          if (model.getAttribute('listener') !== 'true') {\n            model.value = mutableEl.innerHTML;\n          }\n\n          model.addEventListener(\"input\", function (e) {\n            model.setAttribute('listener', 'true');\n            clearTimeout(timer);\n            timer = setTimeout(() => {\n              model.value = mutableEl.innerHTML;\n              model.removeAttribute('listener');\n            }, timeOut);\n          });\n          \n        } else {\n          \n          const modelID = responseObj.syncModelID;\n          \n          // IF modelID IS AN OBJECT, THEN THERE ARE MULTIPLE OBJECTS TO BE SYNCED\n          if (typeof(modelID) === \"object\") {\n            Object.values(modelID).forEach(theID => {\n              document.getElementById(`${theID}`).value = responseObj.mutableVal;\n            });\n          } else {\n            // THERE IS ONLY ONE MODEL TO BE SYNCED\n            document.getElementById(`${modelID}`).value = responseObj.mutableVal; // ?????????????\n          }\n        }\n      }\n    }\n}\n","import { asynDirectives } from '../util/asynDirectives';\n\n/**\n * This is intended to isolate all native DOM operations. The operations that happen\n * one specific element will be instance methods, the operations you would normally\n * perform on the \"document\" (like \"document.querySelector\") will be static methods.\n */\nexport default {\n    allModelElementsInside(root) {\n        return Array.from(root.querySelectorAll(`[asyn\\\\:model]`));\n    },\n\n    getByAttributeAndValue(attribute, value) {\n        return document.querySelector(`[asyn\\\\:${attribute}=\"${value}\"]`);\n    },\n\n    hasAttribute(el, attribute) {\n        return el.hasAttribute(`asyn:${attribute}`);\n    },\n\n    getAttribute(el, attribute) {\n        return el.getAttribute(`asyn:${attribute}`);\n    },\n\n    removeAttribute(el, attribute) {\n        return el.removeAttribute(`asyn:${attribute}`);\n    },\n\n    setAttribute(el, attribute, value) {\n        return el.setAttribute(`asyn:${attribute}`, value);\n    },\n\n    hasFocus(el) {\n        return el === document.activeElement;\n    },\n\n    isInput(el) {\n        return ['INPUT', 'TEXTAREA', 'SELECT'].includes(\n            el.tagName.toUpperCase()\n        );\n    },\n\n    isTextInput(el) {\n        return (\n            ['INPUT', 'TEXTAREA'].includes(el.tagName.toUpperCase()) &&\n            !['checkbox', 'radio'].includes(el.type)\n  );\n    },\n\n    valueFromInput(el, agent) {\n        if (el.type === 'checkbox') {\n            let modelName = asynDirectives(el).get('model').value;\n            // If there is an update from asyn:model.defer in the chamber,\n            // we need to pretend that is the actual data from the server.\n            let modelValue = agent.deferredActions[modelName]\n                ? agent.deferredActions[modelName].asynPayload.value\n                // : get(agent.data, modelName);\n                : el.checked;\n\n            if (Array.isArray(modelValue)) {\n                return this.mergeCheckboxValueIntoArray(el, modelValue);\n            }\n\n            if (el.checked) {\n                return el.getAttribute('value') || true;\n            } else {\n                return false;\n            }\n        } else if (el.tagName === 'SELECT' && el.multiple) {\n            return this.getSelectValues(el);\n        }\n\n        return el.value;\n    },\n\n    mergeCheckboxValueIntoArray(el, arrayValue) {\n        if (el.checked) {\n            return arrayValue.includes(el.value)\n                ? arrayValue\n                : arrayValue.concat(el.value);\n        }\n\n        return arrayValue.filter(item => item != el.value);\n    },\n      \n      setInputValueFromModel(el, agent) {\n          const modelString = asynDirectives(el).get('model').value;\n          const modelValue = get(agent.data, modelString);\n\n          // Don't manually set file input's values.\n          if (\n              el.tagName.toLowerCase() === 'input' &&\n              el.type === 'file'\n          )\n              return;\n\n          this.setInputValue(el, modelValue);\n      },\n\n    setInputValue(el, value) {\n        if (el.type === 'radio') {\n            el.checked = el.value == value;\n        } else if (el.type === 'checkbox') {\n            if (Array.isArray(value)) {\n                // I'm purposely not using Array.includes here because it's\n                // strict, and because of Numeric/String mis-casting, I\n                // want the \"includes\" to be \"fuzzy\".\n                let valueFound = false;\n                value.forEach(val => {\n                    if (val == el.value) {\n                        valueFound = true;\n                    }\n                });\n\n                el.checked = valueFound;\n            } else {\n                el.checked = !!value;\n            }\n        } else if (el.tagName === 'SELECT') {\n            this.updateSelect(el, value);\n        } else {\n            value = value === undefined ? '' : value;\n\n            el.value = value;\n        }\n    },\n\n    getSelectValues(el) {\n        return Array.from(el.options)\n          .filter(option => option.selected)\n          .map(option => option.value || option.text);\n    },\n\n    updateSelect(el, value) {\n        const arrayWrappedValue = [].concat(value).map(value => value + '');\n\n        Array.from(el.options).forEach(option => {\n            option.selected = arrayWrappedValue.includes(option.value);\n        });\n    }\n};\n","import Action from '.';\n\nexport default class extends Action {\n    constructor(modelAttrVal, params, modelVal, isCustomEvent, el, skipWatcher = false) {\n        super(el, skipWatcher);\n\n        this.isCustomEvent = isCustomEvent;\n        this.type = 'callHandler';\n        this.name = modelAttrVal;\n        this.payload = {\n            modelAttrVal,\n            params,\n            modelVal\n        };\n    }\n\n}","import Action from '.';\n\nexport default class extends Action {\n    constructor(modelAttrVal, params, modelVal, isCustomEvent, el) {\n        super(el);\n\n        this.isCustomEvent = isCustomEvent;\n        this.type = 'syncInput';\n        this.name = modelAttrVal;\n        this.payload = {\n            // id: this.signature,\n            modelAttrVal,\n            params,\n            modelVal\n        };\n    }\n}\n","export default class {\n    constructor(agent, updateQueue) {\n        this.agent = agent;\n        this.updateQueue = updateQueue;\n    }\n\n    payload() {\n        return {\n            // This ensures only the type & payload properties only get sent over.\n            updates: this.updateQueue.map(update => ({\n                type: update.type,\n                payload: update.payload\n            }))\n        };\n    }\n\n    storeResponse(payload) {\n      return (this.response = payload);\n    }\n\n}\n","import Message from '../Message';\nimport { debounce } from '../util/debounce';\nimport store from '../Store';\nimport DeferredModelAction from '../action/deferred-model';\nimport { walkDOM } from '../util/walkDOM';\nimport MessageBus from '../MessageBus';\n\nexport default class {\n    constructor(el, connection, postValue, agentID) {\n        this.el = el;\n        this.updateQueue = [];\n        this.deferredActions = {}; // temp test\n        this.messageInTransit = undefined;\n        this.connection = connection;\n        this.postValue = postValue;\n        this.agentID = agentID;\n        this.tearDownCallbacks = [];\n        this.scopedListeners = new MessageBus();\n        this.listeners = [];\n        store.callHook('agent.initialized', this);\n    }\n\n    on(event, callback) {\n      this.scopedListeners.register(event, callback);\n    }\n\n    addAction(action) {\n        if (action instanceof DeferredModelAction) {\n            this.deferredActions[action.name] = action;\n\n            return;\n        }\n\n        this.updateQueue.push(action);\n\n        // This debounce is here in-case two events fire at the \"same\" time:\n        // For example: if you are listening for a click on element A,\n        // and a \"blur\" on element B. If element B has focus, and then,\n        // you click on element A, the blur event will fire before the \"click\"\n        // event. This debounce captures them both in the actionsQueue and sends\n        // them off at the same time.\n        // Note: currently, it's set to 5ms, that might not be the right amount, we'll see.\n        debounce(this.fireMessage, 5).apply(this);\n\n        // Clear prefetches.\n        // this.prefetchManager.clearPrefetches()\n    }\n\n    fireMessage() {\n        Object.entries(this.deferredActions).forEach(([modelName, action]) => {\n          this.updateQueue.unshift(action);\n        });\n        this.deferredActions = {};\n\n        this.messageInTransit = new Message(this, this.updateQueue);\n\n      let sendMessage = () => {\n        this.connection.action(this.messageInTransit);\n\n        store.callHook('message.sent', this, this.messageInTransit);\n\n        this.updateQueue = [];\n      };\n        sendMessage();\n    }\n\n    receiveMessage(message, payload) {\n      message.storeResponse(payload);\n\n        // This bit of logic ensures that if actions were queued while a request was\n        // out to the server, they are sent when the request comes back.\n        if (this.updateQueue.length > 0) {\n          this.fireMessage();\n        }\n    }\n    \n    doReplayResponse(event, agent, response) {\n      this.connection.handleResponse(event, agent, response);\n    }\n\n    walk(callback, callbackWhenNewComponentIsEncountered = el => { }) {\n      walkDOM(this.el, el => {\n        // Skip the root component element.\n        if (el.isSameNode(this.el)) {\n          callback(el);\n          return;\n        }\n\n        if (callback(el) === false) {\n          return false;\n        }\n      });\n    }\n\n    callAfterModelDebounce(callback) {\n        // This is to protect against the following scenario:\n        // A user is typing into a debounced input, and hits the enter key.\n        // If the enter key submits a form or something, the submission\n        // will happen BEFORE the model input finishes syncing because\n        // of the debounce. This makes sure to clear anything in the debounce queue.\n\n        if (this.modelDebounceCallbacks) {\n            this.modelDebounceCallbacks.forEach(callbackRegister => {\n                callbackRegister.callback();\n                callbackRegister.callback = () => { };\n            });\n        }\n\n      callback();\n    }\n\n    addListenerForTeardown(teardownCallback) {\n        this.tearDownCallbacks.push(teardownCallback);\n    }\n\n    tearDown() {\n        this.tearDownCallbacks.forEach(callback => callback());\n    }\n}\n","import { debounce } from './util/debounce';\nimport { kebabCase } from './util';\nimport { asynDirectives } from './util/asynDirectives';\nimport Connection from './connection/index';\nimport DOM from './dom/dom';\nimport HandlerAction from './action/handler';\nimport store from './Store';\nimport ModelAction from './action/model';\nimport DeferredModelAction from './action/deferred-model';\nimport Deferred from './action/Deferred';\nimport Agent from './agent/index';\n\nexport default {\n\n    initialize(el, url, reregisterEvl) {\n        let isAgent = false;\n        asynDirectives(el).all().forEach(directive => {\n            let test;\n            let lcFunc;\n            switch (directive.type) {\n\n            case 'model': {\n                if (!directive.value) {\n                    console.warn('ASYNergy: [asyn:model] is missing a value.', el);\n\n                    break;\n                }\n\n                // CHECK FOR COMPUND MODEL ATTRIBUTE VALUE, USE THE PREFIX\n                // TO CHECK IF THERE IS A CORRESPONDING MUTABLE ELEMENT\n                let directiveVal = '';\n                let compoundAttrVal = directive.value.search(/[.]/);\n                if (compoundAttrVal !== -1) {\n                    const dirValPrefix = /^.+(?=(\\.))/.exec(directive.value);\n                    directiveVal = dirValPrefix[0];\n                } else {\n                    directiveVal = directive.value;\n                }\n\t\t\t\t\t\t\t\n                // GET RID OF THE MODEL PARAMETERS\n                compoundAttrVal = directive.value.search(/[\\(]/);\n                \n                if (compoundAttrVal !== -1) {\n                  const dirVal = /^.+(?=(\\())/.exec(directive.value);\n                  directiveVal = dirVal[0];\n                }\n\n                let mutableElem = document.querySelector(`[asyn\\\\:mutable=${directiveVal}]`);\n\n                // GET ATTRIBUTE\n                let attr = this.modelAttr(directive.fullName, directiveVal);               \n                let modelElem = document.querySelector(`[${attr}]`);\n\n                if (mutableElem !== null) {\n                  this.attachModelListener(el, directive, mutableElem, url, modelElem, directiveVal);\n                } else {\n                    mutableElem = document.querySelector(`[asyn\\\\:mutable^=${directiveVal}\\\\.]`);\n                    if (mutableElem !== null) {\n                      this.attachModelListener(el, directive, mutableElem, url, modelElem, directiveVal);\n                    } else {\n                        console.warn(\n                        'ASYNergy: [asyn:model] is missing a corresponding [asyn:mutable] element.',\n                        el);\n                    }\n                }\n\n                test = 'model';\n                isAgent = true;\n                break;\n            }\n\n            case 'mutable':\n              if (reregisterEvl !== true) {\n\n                if ((typeof directive.el.innerHTML === \"string\") && (directive.el.innerHTML.search(/asyn:/)) !== -1) {\n                  store.mutableIncludesModel = true;\n                }\n\n                lcFunc = directive.lcFunction;\n                store.mutables.push(directive);\n\n                test = 'mutable';\n                isAgent = false;\n              }\n            break;\n\n            case 'transmit':\n                // CHECK IF ELEMENT IS A MUTABLE ELEMENT, NEEDED TO\n                // REPLACE A MODEL CHECKBOX VALUE WITH THE MODEL INPUT VALUE\n                directive.el.mutable = el.getAttributeNames().indexOf('asyn:mutable');\n\n                store.transmissionEls.push(directive.el);\n\n                test = 'transmit';\n                isAgent = true;\n                break;\n\n            case 'csrf':\n                store.csrf.tokenName = directive.value;\n                store.csrf.token = el.value;\n\n                test = 'csrf';\n                isAgent = false;\n                break;\n\n            default:\n              const params = directive.params;\n              let handler = directive.value;\n              if (params.length !== 0) {\n                handler = directive.handler;\n              }\n\n                let mutableElem = document.querySelector(`[asyn\\\\:mutable=${handler}]`);\n                if (mutableElem === null) {\n                    mutableElem = document.querySelector(`[asyn\\\\:mutable^=${handler}\\\\.]`);\n                }\n\n                // GET ATTRIBUTE\n                let attr = this.modelAttr(directive.fullName, directive.value);\n                let modelElem = document.querySelector(`[${attr}]`);\n\n                if (store.directives.has(directive.type)) {\n                    store.directives.call(\n                      directive.type,\n                      el,\n                      directive,\n                      mutableElem,\n                      url\n                          );\n                }\n\n                this.attachDomListener(el, directive, mutableElem, url, modelElem);\n\n                test = 'default';\n                isAgent = true;\n                break;\n        }\n\n        });\n\n        if (isAgent === true) {\n            let index = store.agents.length - 1;\n            let theAgent = store.agents[index];\n            let eventType = theAgent.connection.event;\n            store.callHook('element.initialized', el, theAgent, eventType);\n        }\n        isAgent = false;\n    },\n\n    attachModelListener(el, directive, mutableEl, url, modelEl, modelAttrVal) {\n        const isLazy = directive.modifiers.includes('lazy');\n\n        const debounceIf = (condition, callback, time) =>\n          condition ? directive.modelSyncDebounce(callback, time) : callback;\n\n        const hasDebounceModifier = directive.modifiers.includes('debounce');\n\n      store.callHook('interceptAsynModelAttachListener', directive, el, mutableEl);\n\n        let event = el.tagName.toLowerCase() === 'select'\n        || ['checkbox', 'radio'].includes(el.type)\n        || directive.modifiers.includes('lazy') ? 'change' : 'input';\n        \n        if (el.tagName.toLowerCase() === 'input' && directive.modifiers.includes('blur')) {\n          event = 'blur';\n        }\n\n        let model = modelAttrVal;\n\n        // TODO check for trailing slashes\n        const handlerURL = url + '/' + model;\n      const initConnection = new Connection(handlerURL, mutableEl, model, modelEl, event);\n\n        const connect = {\n            sendMessage: function () {\n                // INPUT FIELD VALUE\n                let postValue = el.value;\n                initConnection.action(postValue);\n            }\n        };\n\n        let agentID = store.agents.length + 1;\n        let agent = store.addAgent(new Agent(el, initConnection, el.value, agentID));\n\n        if (directive.modifiers.includes('defer')) {\n            Deferred.addAction(directive.value, el.value, el);\n        }\n\n        // If it's a text input and not .lazy, debounce, otherwise fire immediately.\n        let handler = debounceIf(hasDebounceModifier || (DOM.isTextInput(el) && !isLazy), e => {\n            let model = directive.value;\n            let params = directive.params;\n            let el = e.target;\n\n            const isCustomEvent = e instanceof CustomEvent;\n\n            isCustomEvent ? directive.emitEvent = true : directive.emitEvent = false;\n\n            let modelVal = e instanceof CustomEvent\n                // We have to check for typeof e.detail here for IE 11.\n                && typeof e.detail != 'undefined'\n                && typeof window.document.documentMode == 'undefined'\n                    // With autofill in Safari, Safari triggers a custom event and assigns\n                    // the value to e.target.value, so we need to check for that value as well.\n                    ? e.detail || e.target.value\n                    : DOM.valueFromInput(el, agent);\n\n            if (directive.modifiers.includes('defer')) {\n                agent.addAction(new DeferredModelAction(model, params, modelVal, isCustomEvent, el));\n            } else {\n                agent.addAction(new ModelAction(model, params, modelVal, isCustomEvent, el));\n            }\n        }, directive.durationOr(150));\n\n        store.addEmitEvent(el, directive.params, directive.handler, handler);\n\n        el.addEventListener(event, handler);\n\n        agent.addListenerForTeardown(() => {\n          el.removeEventListener(event, handler);\n        });\n\n        // Taken from: https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\n      let isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n\n        // Safari is weird and doesn't properly fire input events when\n        // a user \"autofills\" a asyn:model(.lazy) field. So we are\n        // firing them manually for assurance.\n      isSafari && el.addEventListener('animationstart', e => {\n        if (e.animationName !== 'asynergyAutofill') {\n          return;\n        }\n\n        e.target.dispatchEvent(new Event('change', { bubbles: true }));\n        e.target.dispatchEvent(new Event('input', { bubbles: true }));\n      });\n    },\n\n    attachDomListener(el, directive, mutableEl, url, modelEl) {\n        switch (directive.type) {\n        case 'keydown':\n        case 'keyup':\n\n            this.attachListener(el, directive, e => {\n                // Detect system modifier key combinations if specified.\n                const systemKeyModifiers = [\n                 'ctrl',\n                 'shift',\n                 'alt',\n                 'meta',\n                 'cmd',\n                 'super'\n                ];\n                const selectedSystemKeyModifiers = systemKeyModifiers.filter(\n                       key => directive.modifiers.includes(key)\n                   );\n\n                if (selectedSystemKeyModifiers.length > 0) {\n                    const selectedButNotPressedKeyModifiers = selectedSystemKeyModifiers.filter(\n                      key => {\n                                // Alias \"cmd\" and \"super\" to \"meta\"\n                                if (key === 'cmd' || key === 'super') {\n                                    key = 'meta';\n                                }\n                                return !e[`${key}Key`];\n                            }\n                       );\n\n                    if (selectedButNotPressedKeyModifiers.length > 0) {\n                        return false;\n                    }\n                }\n\n                // Handle spacebar\n                if (e.keyCode === 32 || (e.key === ' ' || e.key === 'Spacebar')) {\n                    return directive.modifiers.includes('space');\n                }\n\n                // Strip 'debounce' modifier and time modifiers from modifiers list\n                let modifiers = directive.modifiers.filter(modifier =>\n                        (\n                           !modifier.match(/^debounce$/) &&\n                           !modifier.match(/^[0-9]+m?s$/)\n                       )\n                   );\n\n                // Only handle listener if no, or matching key modifiers are passed.\n                // It's important to check that e.key exists - OnePassword's extension\n                // does weird things.\n                return Boolean(modifiers.length ===\n                  0 || (e.key && modifiers.includes(kebabCase(e.key))));\n            }, mutableEl, url, modelEl);\n\n            break;\n        case 'click':\n\n            this.attachListener(el, directive, e => {\n                // We only care about elements that have the .self modifier on them.\n                if (!directive.modifiers.includes('self')) {\n                    return;\n                }\n\n                // This ensures a listener is only run if the event originated\n                // on the elemenet that registered it (not children).\n                // This is useful for things like modal back-drop listeners.\n              return el.isSameNode(e.target);\n            }, mutableEl, url, modelEl);\n\n            break;\n        default:\n            this.attachListener(el, directive, e => el === e.target, mutableEl, url, modelEl);\n            break;\n    \t\t\t}\n    },\n\n    attachListener(el, directive, callback, mutableEl, url, modelEl) {\n        const event = directive.type;\n        const model = directive.handler;\n\n        // TODO check for trailing slashes\n        const handlerURL = url + '/' + model;\n\n        const initConnection = new Connection(handlerURL, mutableEl, model, modelEl, event);\n\n        let postValue = () => {\n            return el.value !== undefined ? el.value : el.innerText;\n        };\n\n        let agentID = store.agents.length + 1;\n        let agent = store.addAgent(new Agent(el, initConnection, postValue(), agentID));\n\n        const handler = e => {\n            if (callback && callback(e) === false) {\n                return;\n            }\n            \n            const isCustomEvent = e instanceof CustomEvent;\n\n          agent.callAfterModelDebounce(() => {\n            const el = e.target;\n\n            directive.setEventContext(e);\n\n            // This is outside the conditional below so \"asyn:click.prevent\"\n            // without a value still prevents default.\n            this.preventAndStop(e, directive.modifiers);\n            const handler = directive.handler;\n            let params = directive.params;\n            let modelVal = directive.modelValue;\n\n            if (isCustomEvent) {\n              directive.emitEvent = true;\n              if (e.detail !== undefined) {\n                modelVal = e.detail;\n              }\n            } else {\n              directive.emitEvent = false;\n            }\n\n            if (\n              params.length === 0 &&\n              isCustomEvent &&\n              e.detail\n            ) {\n              params.push(e.detail);\n            }\n\n            if (directive.value) {\n              agent.addAction(new HandlerAction(handler, params, modelVal, isCustomEvent, el));\n            }\n\n          });\n        };\n\n        const debounceIf = (condition, callback, time) =>\n          condition ? debounce(callback, time) : callback;\n\n        const hasDebounceModifier = directive.modifiers.includes('debounce');\n        const debouncedHandler = debounceIf(\n           hasDebounceModifier,\n           handler,\n           directive.durationOr(150)\n        );\n\n        store.addEmitEvent(el, directive.params, directive.handler, handler);\n\n        el.addEventListener(event, debouncedHandler);\n\n        agent.addListenerForTeardown(() => {\n          el.removeEventListener(event, debouncedHandler);\n        });\n    },\n    \n    preventAndStop(event, modifiers) {\n      modifiers.includes('prevent') && event.preventDefault();\n      modifiers.includes('stop') && event.stopPropagation();\n    },\n\n    modelAttr(fullName, attrVal) {\n      let escFullName = this.escapedStr(fullName);\n      let escAttrVal = this.escapedStr(attrVal);\n      let attr = escFullName + \"=\" + \"\\\"\" + escAttrVal + \"\\\"\";\n      return attr;\n    },\n    \n    escapedStr(str) {\n      let escapedStr = str;\n      escapedStr = escapedStr.replace(/\\:|\\.|\"|'/gi, function (x) {\n        return \"\\\\\" + x;\n      });\n      return escapedStr;\n    }\n};\n","\nexport * from './debounce';\nexport * from './asynDirectives';\nexport * from './walkDOM';\n\nexport function kebabCase(subject) {\n    return subject.replace(/([a-z])([A-Z])/g, '$1-$2').replace(/[_\\s]/, '-').toLowerCase();\n}\n\nexport function tap(output, callback) {\n    callback(output);\n\n    return output;\n}\n","import store from '../Store';\nimport { asynDirectives } from '../util/asynDirectives';\n\nlet cleanupStackByAgentId = {};\n\nexport default function () {\n  store.registerHook('element.initialized', (el, agent) => {\n    let directives = asynDirectives(el);\n\n    if (directives.missing('submit')) return;\n\n    // Set a forms \"disabled\" state on inputs and buttons.\n    // ASYNergy will clean it all up automatically submitting the form.\n    el.addEventListener('submit', () => {\n      cleanupStackByAgentId[agent.agentID] = [];\n\n      agent.walk(node => {\n        if (!el.contains(node)) return;\n\n        if (node.hasAttribute('asyn:ignore')) return false;\n\n        if (\n          // <button type=\"submit\">\n          (node.tagName.toLowerCase() === 'button' &&\n            node.type === 'submit') ||\n          // <select>\n          node.tagName.toLowerCase() === 'select' ||\n          // <input type=\"checkbox|radio\">\n          (node.tagName.toLowerCase() === 'input' &&\n            (node.type === 'checkbox' || node.type === 'radio'))\n        ) {\n\n          if (!node.disabled)\n            cleanupStackByAgentId[agent.agentID].push(\n              () => (node.disabled = false)\n            );\n\n          node.disabled = true;\n          // TODO: add node to disabled nodes array ---------------------------\n          store.addDisabledNode(node);\n        } else if (\n          // <input type=\"text\">\n          node.tagName.toLowerCase() === 'input' ||\n          // <textarea>\n          node.tagName.toLowerCase() === 'textarea'\n        ) {\n          if (!node.readOnly)\n            cleanupStackByAgentId[agent.agentID].push(\n              () => (node.readOnly = false)\n            );\n\n          node.readOnly = true;\n          // TODO: add node to readOnly nodes array ---------------------------\n          store.addReadOnlyNode(node);\n        }\n      });\n    });\n  });\n\n  store.registerHook('message.failed', (message, agent) => cleanup(agent));\n  store.registerHook('message.received', (message, agent) => cleanup(agent));\n}\n\nfunction cleanup(agent) {\n    if (!cleanupStackByAgentId[agent.agentID]) return;\n\n    while (cleanupStackByAgentId[agent.agentID].length > 0) {\n      cleanupStackByAgentId[agent.agentID].shift()();\n    }\n}\n","import store from '../Store';\nimport Message from '../Message';\n\nexport default function () {\n\n\tlet initializedPath = false;\n\n\tlet agentIdsThatAreWritingToHistoryState = new Set;\n\n\tASYNergyStateManager.clearState();\n    \n\tlet browserHistoryOn = false;\n    \n\tstore.registerHook('agent.initialized', agent => {\n\t\tif (store.mutableIncludesModel === true) {\n        \n\t\t\tif (initializedPath === false) {\n              \n\t\t\t\tlet url = window.location.href;\n              \n\t\t\t\tlet responseItemNum = 0;\n              \n\t\t\t\tlet asynergyResponse = {};\n              \n\t\t\t\tfor (const mutablesItem in store.mutables) {\n\t\t\t\t\tresponseItemNum += 1;\n\n\t\t\t\t\tasynergyResponse[responseItemNum] = {\n\t\t\t\t\t\tmutableID: store.mutables[mutablesItem].el.id,\n\t\t\t\t\t\tsyncModelID: \"\",\n\t\t\t\t\t\tmutableVal: store.mutables[mutablesItem].el.innerHTML,\n\t\t\t\t\t\tmutableAttrVal: store.mutables[mutablesItem].el.getAttribute('asyn:mutable'),\n\t\t\t\t\t};\n\t\t\t\t};\n              \n\t\t\t\tlet response = {\n\t\t\t\t\tasynergyResponse\n\t\t\t\t};\n\n\t\t\t\tASYNergyStateManager.replaceState(url, response, agent);\n\n\t\t\t\tagentIdsThatAreWritingToHistoryState.add(agent.agentID);\n\n\t\t\t\tinitializedPath = true;\n\t\t\t\tbrowserHistoryOn = true;\n\t\t\t};\n\t\t};\n\t});\n\n\n\tstore.registerHook('allMessages.processed', (message) => {\n\t\tif (browserHistoryOn === true) {\n\t\t\t// Preventing a circular dependancy.\n\t\t\tif (message.replaying) return;\n\n\t\t\tlet { response } = message;\n\n\t\t\tlet effects = response.effects || {};\n\n\t\t\tlet url = window.location.href;\n\t\t\tASYNergyStateManager.pushState(url, response, message.agent);\n\n\t\t};\n\t});\n\n\n\twindow.addEventListener('popstate', event => {\n\t\tif (browserHistoryOn === true) {\n        \n\t\t\tif (ASYNergyStateManager.missingState(event)) return;\n\n\t\t\tASYNergyStateManager.replayResponses(event, (response, agent) => {\n \n\t\t\t\tlet updateEl = agent.connection.updateEl;\n\t\t\t\tlet message = new Message(agent, []);\n\n\t\t\t\tmessage.storeResponse(response);\n\n\t\t\t\tmessage.replaying = true;\n\n\t\t\t\tagent.doReplayResponse(event, agent, response);\n\t\t\t});\n\t\t};\n\t});\n}\n\n\nlet ASYNergyStateManager = {\n    replaceState(url, response, agent) {\n\t\t\tthis.updateState('replaceState', url, response, agent);\n    },\n\n    pushState(url, response, agent) {\n\t\t\tthis.updateState('pushState', url, response, agent);\n    },\n\n    updateState(method, url, response, agent) {\n\t\t\tlet state = this.currentState();\n\n\t\t\tstate.storeResponse(response, agent);\n\n\t\t\tlet stateArray = state.toStateArray();\n\n        // Copy over existing history state if it's an object, so we don't overwrite it.\n\t\t\tlet fullstateObject = Object.assign(history.state || {}, { ASYNergy: stateArray });\n\n\t\t\tlet capitalize = subject => subject.charAt(0).toUpperCase() + subject.slice(1);\n\n\t\t\tstore.callHook('before'+capitalize(method), fullstateObject, url, agent);\n\n        try {\n            if (decodeURI(url) != 'undefined') {\n\t\t\t\t\t\t\turl = decodeURI(url).replaceAll(' ', '+').replaceAll('\\\\', '%5C');\n            }\n\n            history[method](fullstateObject, '', url);\n\n        } catch (error) {\n            // Firefox has a 160kb limit to history state entries.\n            // If that limit is reached, we'll instead put it in\n            // sessionStorage and store a reference to it.\n            if (error.name === 'NS_ERROR_ILLEGAL_VALUE') {\n\t\t\t\t\t\t\tlet key = this.storeInSession(stateArray);\n\n\t\t\t\t\t\t\tfullstateObject.asynergy = key;\n\n\t\t\t\t\t\t\thistory[method](fullstateObject, '', url);\n\n            } else {\n              console.error('history.' + method + ': ' + error);\n            };\n        };\n    },\n\n    replayResponses(event, callback) {\n        if (! event.state.ASYNergy) return;\n\n        let state = typeof event.state.ASYNergy === 'string'\n            ? new ASYNergyState(this.getFromSession(event.state.ASYNergy))\n\t\t\t\t: new ASYNergyState(event.state.ASYNergy);\n\n        state.replayResponses(callback);\n    },\n\n    currentState() {\n        if (! history.state) return new ASYNergyState;\n        if (! history.state.ASYNergy) return new ASYNergyState;\n\n        let state = typeof history.state.ASYNergy === 'string'\n            ? new ASYNergyState(this.getFromSession(history.state.ASYNergy))\n\t\t\t\t: new ASYNergyState(history.state.ASYNergy);\n\n        return state;\n    },\n\n    missingState(event) {\n\t\t\treturn ! (event.state && event.state.ASYNergy);\n    },\n\n    clearState() {\n        // This is to prevent exponentially increasing the size of our state on page refresh.\n        if (window.history.state) window.history.state.ASYNergy = (new ASYNergyState).toStateArray();\n    },\n\n    storeInSession(value) {\n\t\t\tlet key = 'asynergy:'+(new Date).getTime();\n\n\t\t\tlet stringifiedValue = JSON.stringify(value);\n\n\t\t\tthis.tryToStoreInSession(key, stringifiedValue);\n\n\t\t\treturn key;\n    },\n\n    tryToStoreInSession(key, value) {\n        // sessionStorage has a max storage limit (usally 5MB).\n        // If we meet that limit, we'll start removing entries\n        // (oldest first), until there's enough space to store\n        // the new one.\n        try {\n\t\t\t\t\tsessionStorage.setItem(key, value);\n        } catch (error) {\n            // 22 is Chrome, 1-14 is other browsers.\n            if (! [22, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14].includes(error.code)) return;\n\n            let oldestTimestamp = Object.keys(sessionStorage)\n                .map(key => Number(key.replace('asynergy:', '')))\n                .sort()\n\t\t\t\t\t\t.shift();\n\n            if (! oldestTimestamp) return;\n\n            sessionStorage.removeItem('asynergy:'+oldestTimestamp);\n\n            this.tryToStoreInSession(key, value);\n        }\n    },\n\n    getFromSession(key) {\n\t\t\tlet item = sessionStorage.getItem(key);\n\n        if (! item) return;\n\n        return JSON.parse(item);\n    },\n}\n\n\nclass ASYNergyState\n{\n    constructor(stateArray = []) { this.items = stateArray };\n\n    toStateArray() { return this.items };\n\n\n    pushItemInProperOrder(signature, response, agent) {\n        let targetItem = { signature, response };\n        \n        // REMOVE CIRCULAR REFERENCE TO AGENT IN agent.messageInTransit\n        // delete agent.messageInTransit;\n\n        // First, we'll check if this signature already has an entry, if so, replace it.\n        let existingIndex = this.items.findIndex(item => item.signature === signature);\n\n        if (existingIndex !== -1) return this.items[existingIndex] = targetItem;\n          \n          return this.items.unshift(targetItem);\n    }\n\n\n    storeResponse(response, agent) {\n      let signature = agent.agentID;\n\n      this.pushItemInProperOrder(signature, response, agent);\n    }\n\n\n\t\treplayResponses(callback) {\n\t\t\tlet state = ASYNergyStateManager.currentState();\n\t\t\tlet signature = state.items[0].signature;\n\t\t\tlet response = state.items[0].response;\n\t\t\tlet agent = this.findAgentBySignature(signature);\n\n\t\t\tif (! agent) return;\n          \n\t\t\tcallback(response, agent);\n\t\t}\n\n\n    findAgentBySignature(signature) {\n      let agent = store.getAgentsByID(signature);\n\n      // If we found the agent in the proper place, return it,\n      // otherwise return the first one.\n      return agent[0] || store.agents[0] || console.warn(`ASYNergy: couldn't find agent with ID: ${signature}`);\n    }\n\n}\n","/*!\n* ASYNergy\n*\n* revIgniter JavaScript application *\n* inspired by and adopted from Livewire *\n* a framework for making network requests *\n* and changing things on the page *\n* Version 0.2.1 *\n*\n* Author: Ralf Bitter, rabit@revigniter.com\n*\n*/\n\n\nimport { walkDOM } from './util/walkDOM';\nimport nodeInitializer from './init_tasks';\nimport store from './Store';\nimport Polling from './agent/Polling';\nimport DisableForms from './agent/DisableForms';\nimport LoadingStates from './agent/LoadingStates';\nimport SyncBrowserHistory from './agent/SyncBrowserHistory';\n\nclass ASYNergy {\n    constructor() {\n      this.appVersion = '0.2.1';\n      this.agents = store;\n      this.URL = '';\n    }\n\n    get version() {\n        return this.appVersion;\n    }\n  \n  set theURL(url) {\n    this.URL = url;\n  }\n\n  get theURL() {\n    return this.URL;\n  }\n\n    hook(name, callback) {\n      this.agents.registerHook(name, callback);\n    }\n\n    emit(event, ...params) {\n      this.agents.emit(event, ...params);\n    }\n\n    on(event, callback) {\n      this.agents.on(event, callback);\n    }\n\n    stop() {\n        this.agents.tearDownAgents();\n    }\n\n    reregisterEventListeners() {\n      const URL = this.URL !== '' ? this.URL : window.location.href;\n      const reregisterEvL = true;\n      const callBackFn = (el) => {\n          nodeInitializer.initialize(el, URL, reregisterEvL);\n      };\n      const bodyEl = document.body;\n      walkDOM(bodyEl, callBackFn);\n    }\n\n    start() {\n        // TODO check forms and handlerURL in init_tasks.js\n      const URL = this.URL !== '' ? this.URL : window.location.href;\n\n        const callBackFn = (el) => {\n            nodeInitializer.initialize(el, URL);\n        };\n\n        const bodyEl = document.body;\n\n        document.addEventListener(\n            'visibilitychange',\n            () => {\n              store.asynergyIsInBackground = document.hidden;\n            },\n            false\n        );\n\n        window.addEventListener('offline', () => {\n            store.asynergyIsOffline = true;\n        });\n\n        window.addEventListener('online', () => {\n            store.asynergyIsOffline = false;\n        });\n\n        walkDOM(bodyEl, callBackFn);\n    }\n}\n\nif (!window.ASYNergy) {\n    window.ASYNergy = ASYNergy;\n}\n\nSyncBrowserHistory();\nLoadingStates();\nDisableForms();\nPolling();\n\n\nexport default ASYNergy;\n","import store from '../Store';\nimport { asynDirectives } from '../util/asynDirectives';\n\nexport default function () {\n    store.registerHook('agent.initialized', agent => {\n      agent.targetedLoadingElsByAction = {};\n      agent.genericLoadingEls = [];\n      agent.currentlyActiveLoadingEls = [];\n      agent.currentlyActiveUploadLoadingEls = [];\n    });\n\n    store.registerHook('element.initialized', (el, agent) => {\n      let directives = asynDirectives(el);\n\n        if (directives.missing('loading')) return;\n\n        const loadingDirectives = directives.directives.filter(\n            i => i.type === 'loading'\n        );\n    });\n\n\n    store.registerHook('message.sent', (agent, message) => {\n        const actions = message.updateQueue\n            .filter(action => {\n              return action.type === 'callHandler';\n            })\n            .map(action => action.payload.modelAttrVal);\n\n        const actionsWithParams = message.updateQueue\n            .filter(action => {\n              return action.type === 'callHandler';\n            })\n            .map(action =>\n                generateSignatureFromHandlerAndParams(\n                  action.payload.modelAttrVal,\n                    action.payload.params\n                )\n            );\n\n      const models = message.updateQueue\n        .filter(action => {\n          return action.type === 'syncInput';\n        })\n        .map(action => {\n          let name = action.payload.modelAttrVal;\n          if (!name.includes('.')) {\n            return name;\n          }\n\n          let modelActions = [];\n\n          modelActions.push(\n            name.split('.').reduce((fullAction, part) => {\n              modelActions.push(fullAction);\n\n              return fullAction + '.' + part;\n            })\n          );\n\n          return modelActions;\n        })\n        .flat();\n    });\n}\n\nexport function setUploadLoading(agent, modelName) {\n    const actionTargetedEls =\n  agent.targetedLoadingElsByAction[modelName] || [];\n\n  const allEls = removeDuplicates(agent.genericLoadingEls.concat(actionTargetedEls));\n\n  startLoading(allEls);\n\n  agent.currentlyActiveUploadLoadingEls = allEls;\n}\n\n\nexport function unsetUploadLoading(agent) {\n  endLoading(agent.currentlyActiveUploadLoadingEls);\n\n  agent.currentlyActiveUploadLoadingEls = [];\n}\n\n\nfunction startLoading(els) {\n    els.forEach(({ el, directive }) => {\n        if (directive.modifiers.includes('class')) {\n          let classes = directive.value.split(' ').filter(Boolean);\n\n            doAndSetCallbackOnElToUndo(\n                el,\n                directive,\n                () => el.classList.add(...classes),\n                () => el.classList.remove(...classes)\n            );\n        } else if (directive.modifiers.includes('attr')) {\n            doAndSetCallbackOnElToUndo(\n                el,\n                directive,\n                () => el.setAttribute(directive.value, true),\n                () => el.removeAttribute(directive.value)\n            );\n        } else {\n            let cache = window\n                .getComputedStyle(el, null)\n          .getPropertyValue('display');\n\n            doAndSetCallbackOnElToUndo(\n                el,\n                directive,\n                () => {\n                  el.style.display = directive.modifiers.includes('remove')\n                    ? cache\n                    : getDisplayProperty(directive);\n                },\n                () => {\n                  el.style.display = 'none';\n                }\n            );\n        }\n    });\n}\n\n\nfunction getDisplayProperty(directive) {\n    return (['inline', 'block', 'table', 'flex', 'grid', 'inline-flex']\n  .filter(i => directive.modifiers.includes(i))[0] || 'inline-block');\n}\n\n\nfunction doAndSetCallbackOnElToUndo(el, directive, doCallback, undoCallback) {\n  if (directive.modifiers.includes('remove'))\n    [doCallback, undoCallback] = [undoCallback, doCallback];\n\n    if (directive.modifiers.includes('delay')) {\n      let duration = 200;\n\n        let delayModifiers = {\n            'shortest': 50,\n            'shorter': 100,\n            'short': 150,\n            'long': 300,\n            'longer': 500,\n            'longest': 1000,\n        };\n\n        Object.keys(delayModifiers).some(key => {\n            if(directive.modifiers.includes(key)) {\n              duration = delayModifiers[key];\n              return true;\n            }\n        });\n\n      let timeout = setTimeout(() => {\n        doCallback();\n        el.__asynergy_on_finish_loading.push(() => undoCallback());\n      }, duration);\n\n      el.__asynergy_on_finish_loading.push(() => clearTimeout(timeout));\n    } else {\n      doCallback();\n      el.__asynergy_on_finish_loading.push(() => undoCallback());\n    }\n}\n\n\nfunction endLoading(els) {\n  els.forEach(({ el }) => {\n    while (el.__asynergy_on_finish_loading.length > 0) {\n      el.__asynergy_on_finish_loading.shift()();\n    }\n  });\n}\n\n\nfunction generateSignatureFromHandlerAndParams(handler, params) {\n  return handler + btoa(encodeURIComponent(handler.toString()));\n}\n\n\nfunction removeDuplicates(arr) {\n  return Array.from(new Set(arr));\n}\n","import HandlerAction from '../action/handler';\nimport { asynDirectives } from '../util/asynDirectives';\nimport store from '../Store';\n\nexport default function () {\n    store.registerHook('element.initialized', (el, agent) => {\n        let directive = asynDirectives(el).get('poll');\n\n        if (directive === undefined) {\n            return;\n        }\n\n        let intervalId = fireActionOnInterval(el, agent);\n\n        agent.addListenerForTeardown(() => {\n          clearInterval(intervalId);\n        });\n\n        el.__asynergy_polling_interval = intervalId;\n    });\n}\n\nfunction fireActionOnInterval(node, agent) {\n    let interval = asynDirectives(node).get('poll').durationOr(2000);\n\n    return setInterval(() => {\n        if (node.isConnected === false) {\n            return;\n        }\n\n        const directive = asynDirectives(node).get('poll');\n\n        if (directive === undefined) {\n            return;\n        }\n\n        const handler = directive.handler || 'refresh';\n\n        // Don't poll when the tab is in the background.\n        // (unless the \"asyn:poll.keep-alive\" modifier is attached)\n        if (store.asynergyIsInBackground && !directive.modifiers.includes('keep-alive')) {\n            // This \"Math.random\" business effectivlly prevents 95% of requests\n            // from executing. We still want \"some\" requests to get through.\n            if (Math.random() < .95) {\n                return;\n            }\n        }\n\n        // Only poll visible elements. Visible elements are elements that\n        // are visible in the current viewport.\n        if (directive.modifiers.includes('visible') && !inViewport(directive.el)) {\n            return;\n        }\n\n        // Don't poll if asynergy is offline as well.\n        if (store.asynergyIsOffline) {\n            return;\n        }\n        agent.addAction(new HandlerAction(handler, directive.params, directive.modelValue, directive.emitEvent, node));\n    }, interval);\n}\n\nfunction inViewport(el) {\n    var bounding = el.getBoundingClientRect();\n\n    return (\n        bounding.top < (window.innerHeight || document.documentElement.clientHeight) &&\n        bounding.left < (window.innerWidth || document.documentElement.clientWidth) &&\n        bounding.bottom > 0 &&\n        bounding.right > 0\n    );\n}\n"]}