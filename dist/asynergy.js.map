{"version":3,"sources":["../src/util/walkDOM.js","../src/util/debounce.js","../src/util/asynDirectives.js","../src/action/index.js","../src/action/event.js","../src/util/dispatch.js","../src/MessageBus.js","../src/HookManager.js","../src/Store.js","../src/DirectiveManager.js","../src/action/deferred-model.js","../src/action/Deferred.js","../src/connection/index.js","../src/dom/dom.js","../src/action/handler.js","../src/action/model.js","../src/Message.js","../src/agent/index.js","../src/init_tasks.js","../src/util/index.js","../src/agent/DisableForms.js","../src/index.js","../src/agent/LoadingStates.js","../src/agent/Polling.js"],"names":["walkDOM","rootEl","callback","node","firstElementChild","nextElementSibling","debounce","func","wait","immediate","timeout","context","this","args","arguments","later","apply","callNow","clearTimeout","setTimeout","asynDirectives","el","DirectiveManager","[object Object]","directives","extractTypeModifiersAndValue","type","map","directive","includes","has","find","Array","from","getAttributeNames","filter","name","match","RegExp","modifiers","replace","split","Directive","fullName","eventContext","lcFunc","emitEvent","isEmitEvent","theBool","value","getAttribute","lcFunction","fullVal","search","modelValue","undefined","innerText","handler","parseOutHandlerAndParams","params","defaultDuration","durationInMilliSeconds","durationInMilliSecondsString","mod","durationInSecondsString","Number","rawHandler","handlerAndParamString","Function","fallback","time","modelDebounceCallbacks","callbackRegister","push","e","Action","skipWatcher","updateQueue","EventAction","modelAttrVal","modelVal","isCustomEvent","super","payload","btoa","encodeURIComponent","event","JSON","stringify","dispatch","eventName","options","theHandler","CustomEvent","addEventListener","dispatchEvent","MessageBus","listeners","forEach","Object","keys","HookManager","availableHooks","bus","register","call","store","csrf","transmissionEls","mutables","mutableElem","url","asynergyIsInBackground","asynergyIsOffline","hooks","agents","nodesSetToDisabled","nodesSetToReadOnly","key","agent","length","agentsLength","i","index","removeAgent","agentsListeningForEvent","addAction","theAgents","directiveParams","handlerName","on","paramsA","modelParams","selectValues","isArray","toString","checked","detail","option","indexOf","setAttribute","removeAttribute","tearDown","splice","listenerType","modelValueKey","transmissionElIsCheckbox","transmissionElIsRadio","transmissionElIsMutable","mutable","isChecked","transmissionElsData","tagName","innerHTML","modelData","theNode","disabled","readOnly","mutablesData","mutableAttrVal","mutableInnerHTML","id","DeferredModelAction","Deferred","deferredActions","deferredActionsData","payloadDeferred","action","hasOwnProperty","actionData","exec","substr","Connection","URL","updateEl","modelEl","ajax","completed_callback","headers","asynPayload","actionType","modelSyncTimeout","clearDisabledReadOnlyNodesArrays","message","updates","tokenName","token","mutabelsData","deferredModelData","fetch","method","Content-Type","X-Requested-With","Accept","X-ASYNergy","Referer","window","location","href","body","then","response","ok","callHook","text","responseObj","parse","values","asynergyResponse","respItem","mutableVal","updated","updateMutablesByID","updateMutablesByAttrVal","syncModels","catch","error","console","warn","mutableID","theID","document","getElementById","nodeName","attrValFragments","attrValPrefix","syncModelID","modelID","timer","model","mutableEl","timeOut","DOM","allModelElementsInside","root","querySelectorAll","getByAttributeAndValue","attribute","querySelector","hasAttribute","hasFocus","activeElement","isInput","toUpperCase","isTextInput","modelName","get","mergeCheckboxValueIntoArray","multiple","getSelectValues","arrayValue","concat","item","modelString","data","toLowerCase","setInputValue","valueFound","val","updateSelect","selected","arrayWrappedValue","HandlerAction","ModelAction","Message","update","Agent","connection","postValue","agentID","messageInTransit","tearDownCallbacks","scopedListeners","fireMessage","entries","unshift","sendMessage","callbackWhenNewComponentIsEncountered","isSameNode","teardownCallback","nodeInitializer","isAgent","all","directiveVal","compoundAttrVal","attr","modelAttr","modelElem","attachModelListener","attachDomListener","theAgent","eventType","isLazy","hasDebounceModifier","initConnection","addAgent","condition","modelSyncDebounce","debounceIf","target","documentMode","valueFromInput","durationOr","addEmitEvent","addListenerForTeardown","removeEventListener","test","navigator","userAgent","animationName","Event","bubbles","attachListener","selectedSystemKeyModifiers","keyCode","modifier","Boolean","subject","kebabCase","callAfterModelDebounce","setEventContext","preventAndStop","debouncedHandler","preventDefault","stopPropagation","attrVal","escapedStr","str","x","cleanupStackByAgentId","cleanup","shift","ASYNergy","appVersion","version","theURL","registerHook","emit","tearDownAgents","bodyEl","hidden","initialize","targetedLoadingElsByAction","genericLoadingEls","currentlyActiveLoadingEls","currentlyActiveUploadLoadingEls","missing","generateSignatureFromHandlerAndParams","modelActions","reduce","fullAction","part","flat","walk","contains","addDisabledNode","addReadOnlyNode","intervalId","interval","setInterval","isConnected","Math","random","bounding","getBoundingClientRect","top","innerHeight","documentElement","clientHeight","left","innerWidth","clientWidth","bottom","right","inViewport","fireActionOnInterval","clearInterval","__asynergy_polling_interval"],"mappings":"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","sourcesContent":["export function walkDOM(rootEl, callback) {\n    if (callback(rootEl) === false) {\n        return;\n    }\n\n    let node = rootEl.firstElementChild;\n\n    while (node) {\n        walkDOM(node, callback);\n        node = node.nextElementSibling;\n    }\n}\n","export function debounce(func, wait, immediate) {\n    var timeout;\n    return function () {\n        var context = this;\n        var args = arguments;\n        var later = function () {\n            timeout = null;\n            if (!immediate) {\n                func.apply(context, args);\n            }\n        };\n\n        var callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n            func.apply(context, args);\n        }\n    };\n}\n","export function asynDirectives(el) {\n    return new DirectiveManager(el);\n}\n\nclass DirectiveManager {\n    constructor(el) {\n        this.el = el;\n        this.directives = this.extractTypeModifiersAndValue();\n    }\n\n    all() {\n        return this.directives;\n    }\n\n    has(type) {\n        return this.directives.map(directive => directive.type).includes(type);\n    }\n\n    missing(type) {\n        return !this.has(type);\n    }\n\n    get(type) {\n        return this.directives.find(directive => directive.type === type);\n    }\n\n    extractTypeModifiersAndValue() {\n        return Array.from(this.el.getAttributeNames()\n\n        // FILTER ONLY THE ASYNergy DIRECTIVES\n        .filter(name => name.match(new RegExp('asyn:')))\n\n        // PARSE OUT THE TYPE, MODIFIERS, AND VALUE FROM IT\n        .map(name => {\n                const [type, ...modifiers] = name.replace(new RegExp('asyn:'), '').split('.');\n\n                return new Directive(type, modifiers, name, this.el);\n            }));\n    }\n}\n\nclass Directive {\n    constructor(type, modifiers, fullName, el) {\n        this.type = type;\n        this.modifiers = modifiers;\n        this.fullName = fullName;\n        this.el = el;\n        this.eventContext;\n        this.lcFunc = null;\n        this.emitEvent = false;\n    }\n\n    setEventContext(context) {\n        this.eventContext = context;\n    }\n    \n    get isEmitEvent() {\n      return emitEvent;\n    }\n    \n    set isEmitEvent(theBool) {\n      if (typeof theBool == \"boolean\") {\n        this.emitEvent = theBool;\n      }\n    }\n\n    get value() {\n        return this.el.getAttribute(this.fullName);\n    }\n    \n    get lcFunction() {\n      if (this.fullName === \"asyn:mutable\") {\n        const fullVal = this.el.getAttribute(this.fullName);\n\n        // GET LIVECODE FUNCTION TO BE CALLED\n        const pos = fullVal.search(/\\./);\n        if (pos !== -1) {\n            this.lcFunc = fullVal.split(\".\")[1];\n        }\n      }\n      return this.lcFunc;\n    }\n    \n    get modelValue() {\n      return this.el.value !== undefined ? this.el.value : this.el.innerText;\n    }\n\n    get handler() {\n      const { handler } = this.parseOutHandlerAndParams(this.value);\n      return handler;\n    }\n\n    get params() {\n      const { params } = this.parseOutHandlerAndParams(this.value);\n\n        return params;\n    }\n\n    durationOr(defaultDuration) {\n        let durationInMilliSeconds;\n        const durationInMilliSecondsString = this.modifiers.find(mod => mod.match(/([0-9]+)ms/));\n        const durationInSecondsString = this.modifiers.find(mod => mod.match(/([0-9]+)s/));\n\n        if (durationInMilliSecondsString) {\n            durationInMilliSeconds = Number(durationInMilliSecondsString.replace('ms', ''));\n        } else if (durationInSecondsString) {\n            durationInMilliSeconds = Number(durationInSecondsString.replace('s', '')) * 1000;\n        }\n\n        return durationInMilliSeconds || defaultDuration;\n    }\n\n    parseOutHandlerAndParams(rawHandler) {\n      let handler = rawHandler;\n        let params = [];\n        const handlerAndParamString = handler.match(/(.*?)\\((.*)\\)/s);\n\n        if (handlerAndParamString) {\n          handler = handlerAndParamString[1];\n\n            // USE A FUNCTION THAT RETURNS IT'S ARGUMENTS TO PARSE AND EVAL ALL PARAMS\n            // THIS \"$EVENT\" IS FOR USE INSIDE THE ASYNergy EVENT HANDLER\n            // ---------------- $event NOT USED ----------------------- //\n            let func = new Function('$event', `return (function () {\n              for (var l=arguments.length, p=new Array(l), k=0; k<l; k++) {\n                p[k] = arguments[k];\n              }\n              return [].concat(p);\n            })(${handlerAndParamString[2]})`);\n\n            params = func(this.eventContext);\n        }\n        return { handler, params };\n    }\n\n    cardinalDirectionOr(fallback = 'right') {\n        if (this.modifiers.includes('up')) {\n            return 'up';\n        }\n        if (this.modifiers.includes('down')) {\n            return 'down';\n        }\n        if (this.modifiers.includes('left')) {\n            return 'left';\n        }\n        if (this.modifiers.includes('right')) {\n            return 'right';\n        }\n        return fallback;\n    }\n\n    modelSyncDebounce(callback, time) {\n        // Prepare yourself for what's happening here.\n        // Any text input with asyn:model on it should be \"debounced\" by ~150ms by default.\n        // We can't use a simple debounce function because we need a way to clear all the pending\n        // debounces if a user submits a form or performs some other action.\n        // This is a modified debounce function that acts just like a debounce, except it stores\n        // the pending callbacks in a global property so we can \"clear them\" on command instead\n        // of waiting for their setTimeouts to expire.\n        if (!this.modelDebounceCallbacks) {\n            this.modelDebounceCallbacks = [];\n        }\n\n        // This is a \"null\" callback. Each asyn:model will register one of these upon initialization.\n        let callbackRegister = { callback: () => { } };\n\n        this.modelDebounceCallbacks.push(callbackRegister);\n\n        // This is a normal \"timeout\" for a debounce function.\n        var timeout;\n\n        return e => {\n            clearTimeout(timeout);\n\n            timeout = setTimeout(() => {\n                callback(e);\n                timeout = undefined;\n\n                // Because we just called the callback, let's return the\n                // callback register to it's normal \"null\" state.\n                callbackRegister.callback = () => { };\n            }, time);\n\n            // Register the current callback in the register as a kind-of \"escape-hatch\".\n            callbackRegister.callback = () => {\n                clearTimeout(timeout);\n                callback(e);\n            };\n        };\n    }\n}\n","export default class {\n    constructor(el, skipWatcher = false) {\n        this.el = el;\n        this.skipWatcher = skipWatcher;\n        this.updateQueue = [];\n    }\n}\n","import Action from '.';\n\nexport default class extends Action {\n    constructor(modelAttrVal, params, modelVal, isCustomEvent, el) {\n      super(el);\n\n      this.isCustomEvent = isCustomEvent;\n      this.type = 'fireEvent';\n      this.name = modelAttrVal;\n        this.payload = {\n            modelAttrVal,\n            params,\n            modelVal\n        };\n    }\n\n    // Overriding toId() becuase some EventActions don't have an \"el\"\n    toId() {\n        return btoa(encodeURIComponent(this.type, this.payload.event, JSON.stringify(this.payload.params)));\n    }\n}\n","export function dispatch(el, eventName, options, theHandler) {\n    const event = new CustomEvent(eventName, options);\n    el.addEventListener(eventName, theHandler);\n    el.dispatchEvent(event);\n}","\nexport default class MessageBus {\n    constructor() {\n        this.listeners = {};\n    }\n\n    register(name, callback) {\n        if (!this.listeners[name]) {\n            this.listeners[name] = [];\n        }\n\n        this.listeners[name].push(callback);\n    }\n\n    call(name, ...params) {\n        (this.listeners[name] || []).forEach(callback => {\n            callback(...params);\n        });\n    }\n\n    has(name) {\n        return Object.keys(this.listeners).includes(name);\n    }\n}\n","import MessageBus from './MessageBus';\n\nexport default {\n  availableHooks: [\n    /**\n     * Public Hooks\n     */\n    'agent.initialized',\n    'element.initialized',\n    'element.updating',\n    'element.updated',\n    'element.removed',\n    'message.sent',\n    'message.failed',\n    'message.received',\n    'message.processed',\n\n    /**\n     * Private Hooks\n     */\n    'interceptAsynModelSetValue',\n    'interceptAsynModelAttachListener',\n    'beforeReplaceState',\n    'beforePushState'\n  ],\n\n  bus: new MessageBus(),\n\n  register(name, callback) {\n    if (!this.availableHooks.includes(name)) {\n      throw `ASYNergy: Referencing unknown hook: [${name}]`;\n    }\n\n    this.bus.register(name, callback);\n  },\n\n  call(name, ...params) {\n    this.bus.call(name, ...params);\n  }\n};\n","import EventAction from './action/event';  // ----------------------- temp test events\nimport { dispatch } from './util/dispatch'; // ------------------------------ temp test events\nimport HookManager from './HookManager';\nimport MessageBus from './MessageBus'; // -------- temp test events\nimport DirectiveManager from './DirectiveManager';\n// import Agent from './agent/index';\n\nconst store = {\n    csrf: {},\n    transmissionEls: [],\n    mutables: [],\n    directives: DirectiveManager,\n    asynergyIsInBackground: false,\n    asynergyIsOffline: false,\n    hooks: HookManager,\n    agents: [],\n    listeners: new MessageBus(),\n    nodesSetToDisabled: [],\n    nodesSetToReadOnly: [],\n\n    theAgents() {\n      return Object.keys(this.agents).map(key => {\n        return this.agents[key];\n      });\n    },\n\n    registerHook(name, callback) {\n        this.hooks.register(name, callback);\n    },\n\n    callHook(name, ...params) {\n        this.hooks.call(name, ...params);\n    },\n\n    addAgent(agent) {\n        this.agents.push(agent);\n        return this.agents[this.agents.length - 1];\n    },\n\n    tearDownAgents() {\n        let agentsLength = this.agents.length;\n        for (let i = 0; i < agentsLength; i++) {\n            let index = this.agents.length - 1;\n            this.removeAgent(this.agents[index], index);\n        }\n    },\n\n    emit(event, ...params) {\n      this.listeners.call(event, ...params);\n        this.agentsListeningForEvent(event).forEach(agent => {\n          agent.addAction(new EventAction(event, params));\n        });\n    },\n\n    agentsListeningForEvent(event) {\n        return this.theAgents().filter(agent => {\n          return agent.listeners.includes(event);\n        });\n    },\n    \n    addEmitEvent(el, directiveParams, handlerName, handler) {\n      let options = {};\n      const eventHandler = (...paramsA) => {\n        \n        const modelParams = [];\n        modelParams[0] = [];\n        let selectValues;\n        \n        if (paramsA !== undefined & paramsA.length !== 0) {\n          if (paramsA[0] !== undefined & paramsA[0].length !== 0) {\n            modelParams[0] = paramsA[0].split(',');\n          }\n\n          if (Array.isArray(paramsA) & (modelParams[0].toString() === directiveParams.toString())) {\n            \n            switch(el.type) {             \n              case 'text':\n                if (paramsA[1] !== undefined) {\n                  el.value = paramsA[1];\n                }\n\n                break;\n              \n              case 'checkbox':\n                if (paramsA[2] !== undefined) {\n                  el.checked = paramsA[2];\n                }\n                \n                break;\n\t\t\t\t\t\t\n              case 'radio':\n                if (paramsA[2] !== undefined) {\n                  el.checked = paramsA[2];\n                }\n                \n                break;\n                \n              case 'select-multiple':\n                if (paramsA[1] !== undefined) {\n                  selectValues = paramsA[1].split(',');\n                }\n                \n                if (selectValues !== undefined) {\n                  options.detail = selectValues;\n                }\n\n                for (const option of el.options) {\n                  if (selectValues.indexOf(option.value) !== -1) {\n                    option.setAttribute('selected', 'selected');\n                  } else {\n                    option.removeAttribute('selected');\n                  }\n                }\n                \n                break;\n\n              case 'submit':\n                if ( paramsA[1] !== undefined) {\n                  const modelValue = paramsA[1].split(',');\n                \n                  if (modelValue !== undefined) {\n                    options.detail = modelValue;\n                  }\n                }\n                \n                break;\n            }\n\n            dispatch(el, handlerName, options, handler);\n          }\n        } else { // if (paramsA !== undefined)\n          dispatch(el, handlerName, options, handler);\n        }\n      };\n      this.on(handlerName, eventHandler);\n    },\n\n    on(event, callback) {\n      this.listeners.register(event, callback);\n    },\n\n    removeAgent(agent, index) {\n        // Remove event listeners attached to the DOM.\n        agent.tearDown();\n        // Remove the component from the store.\n        // delete this.agents[index];\n        this.agents.splice(index, 1);\n    },\n\n      transmissionElsData(payload, listenerType, modelValueKey) {\n          if (this.transmissionEls[0] !== undefined) {\n            let index;\n            for (index = 0; index < this.transmissionEls.length; index++) {\n                const transmissionElIsCheckbox = this.transmissionEls[index].type === 'checkbox';\n\t\t\t\t\t\t\tconst transmissionElIsRadio = this.transmissionEls[index].type === 'radio';\n                const transmissionElIsMutable = this.transmissionEls[index].mutable >= 0;\n\t\t\t\t\t\t\t\n                if (transmissionElIsCheckbox) {\n                    const isChecked = this.transmissionEls[index].checked;\n                    payload.transmissionElsData[this.transmissionEls[index].getAttribute('asyn:transmit')] = isChecked ? this.transmissionEls[index].value : 'false';\n\t\t\t\t\t\t\t\n\t              } else if (transmissionElIsRadio) {\n\t                  const isChecked = this.transmissionEls[index].checked;\n\t                  if (isChecked) {\n\t                      payload.transmissionElsData[this.transmissionEls[index].getAttribute('asyn:transmit')] = this.transmissionEls[index].value;\n\t                  }\n\t\t\t\t\t\t\t\n                } else {\n                    payload.transmissionElsData[this.transmissionEls[index].getAttribute('asyn:transmit')] = (this.transmissionEls[index].tagName === 'INPUT') || (this.transmissionEls[index].tagName === 'TEXTAREA') || (this.transmissionEls[index].tagName === 'SELECT') ? this.transmissionEls[index].value : this.transmissionEls[index].innerHTML;\n\n                    // REPLACE CHECKBOX MODEL VALUE WITH MUTABLE ELEMENT DATA\n                    if (listenerType === 'checkbox' && transmissionElIsMutable) {\n                        payload.modelData[modelValueKey] = this.transmissionEls[index].innerHTML;\n                    }\n\n                }\n            }\n        }\n        return payload;\n    },\n\n    addDisabledNode(theNode) {\n      this.nodesSetToDisabled.push(theNode);\n    },\n\n    addReadOnlyNode(theNode) {\n      this.nodesSetToReadOnly.push(theNode);\n    },\n\n    clearDisabledReadOnlyNodesArrays() {\n      let index;\n\n      for (index = 0; index < this.nodesSetToDisabled.length; index++) {\n        this.nodesSetToDisabled[index].disabled = false;\n      }\n      this.nodesSetToDisabled.length = 0;\n\n      for (index = 0; index < this.nodesSetToReadOnly.length; index++) {\n        this.nodesSetToReadOnly[index].readOnly = false;\n      }\n      this.nodesSetToReadOnly.length = 0;\n    },\n\n    mutabelsData(payload) {\n      if (this.mutables[0] !== undefined) {\n        let index;\n        for (index = 0; index < this.mutables.length; index++) {\n\n          payload.mutablesData[index] = {};\n          payload.mutablesData[index].mutableAttrVal = this.mutables[index].value;\n          payload.mutablesData[index].el = this.mutables[index].el;\n          payload.mutablesData[index].mutableInnerHTML = this.mutables[index].el.innerHTML;\n          payload.mutablesData[index].lcFunc = this.mutables[index].lcFunc;\n          payload.mutablesData[index].id = this.mutables[index].el.id;\n        }\n      } else {\n        payload.mutablesData = null;\n      }\n      \n      return payload;\n    }\n};\n\nexport default store;\n","import MessageBus from './MessageBus';\n\nexport default {\n    directives: new MessageBus(),\n\n    register(name, callback) {\n        if (this.has(name)) {\n            throw `ASYNergy: Directive already registered: [${name}]`;\n        }\n\n        this.directives.register(name, callback);\n    },\n\n    call(name, el, directive, mutableElem, url) {\n        this.directives.call(name, el, directive, mutableElem, url);\n    },\n\n    has(name) {\n        return this.directives.has(name);\n    }\n};\n","import Action from '.';\n\nexport default class extends Action {\n    constructor(modelAttrVal, params, modelVal, isCustomEvent, el, skipWatcher = false) {\n        super(el, skipWatcher);\n\n        this.isCustomEvent = isCustomEvent;\n        this.type = 'syncInput';\n        this.name = modelAttrVal;\n        this.payload = {\n            modelAttrVal,\n            params,\n            modelVal\n        };\n    }\n}\n","import DeferredModelAction from './deferred-model';\n\nexport default {\n  deferredActions: {},\n\n  addAction(name, value, el) {\n    if (!this.deferredActions[name]) {\n      new DeferredModelAction(name, value, el);\n      this.deferredActions[name] = [];\n    }\n\n    this.deferredActions[name].push(value);\n    this.deferredActions[name].push(el);\n  },\n\n  get deferredActionsData() {\n    let payloadDeferred = {};\n\n    if (this.deferredActions.length !== 0) {\n\n      // GET NAMES AND VALUES OF DEFERRED ACTIONS\n      for (let action in this.deferredActions) {\n        if (this.deferredActions.hasOwnProperty(action)) {\n          let actionData = this.deferredActions[action];\n\n          // actionData[0], IS THE INITIAL VALUE actionData[1] IS THE ELEMENT\n          // this.asynPayload[action] = actionData[1].value;\n          // USE THE ACTION SUFFIX AS PAYLOAD KEY\n\n          // REGULAR EXPRESSION (?<=(\\.)).+$ DOES NOT WORK WITH WEBKIT\n          // DUE TO LOOKBEHIND. WE USE (?:(\\.)).+$ AND STRIP THE FIRST\n          // CHARACTER, A DOT IN THIS CASE\n          // const actionSuffix = /(?<=(\\.)).+$/.exec(action);\n          // this.asynPayload[actionSuffix[0]] = actionData[1].value;\n          const actionExecResult = /(?:(\\.)).+$/.exec(action);\n          const actionSuffix = actionExecResult[0].substr(1);\n          payloadDeferred[actionSuffix] = actionData[1].value;\n        }\n      }\n    }\n    return payloadDeferred;\n  }\n};\n","import store from '../Store';\nimport Deferred from '../action/Deferred';\n\nexport default class Connection {\n  constructor(URL, updateEl, modelAttrVal, modelEl, event) {\n        this.url = URL;\n        this.updateEl = updateEl;\n        // this.postKey = postKey;\n        this.modelAttrVal = modelAttrVal;\n        this.event = event;\n        this.action = this.ajax;\n        this.callback = this.completed_callback;\n        this.headers = '';\n      this.asynPayload = {};\n      this.mutablesData = [];\n      this.modelEl = modelEl;\n      this.actionType = '';\n      this.modelSyncTimeout = 1000;\n      this.isCustomEvent = undefined;\n    }\n\n    // FETCH COMPLETED ACTION //\n    completed_callback(updateEl) {\n      store.clearDisabledReadOnlyNodesArrays();\n\t\t\t// store.callHook // allProcessed\n    }\n    \n\n    ajax(message) {\n        const payload = message.payload();\n        const modelVal = payload.updates[0].payload.modelVal;\n        const listenerType = message.agent.el.type;\n        const modelParams = payload.updates[0].payload.params;\n\n        this.asynPayload = {};\n\n        this.asynPayload.modelData = {'modelAttrVal': this.modelAttrVal, 'modelVal': modelVal, 'modelParams': modelParams};\n\n        // CSRF\n        if (store.csrf.tokenName !== undefined && store.csrf.token !== '') {\n            this.asynPayload[store.csrf.tokenName] = store.csrf.token;\n        }\n        \n        // GET MUTABLE ELEMENTS DATA\n        this.asynPayload.mutablesData = [];\n        this.asynPayload = store.mutabelsData(this.asynPayload);\n        this.mutablesData = this.asynPayload.mutablesData;\n        \n        if (this.mutablesData === null) {\n          console.warn(\"Missing data of any mutable element!\");\n          return;\n        }\n        \n        if (this.updateEl === null) {\n          this.updateEl = this.mutablesData[0].el;\n        }\n        let index;\n\n        var mutableAttrVal = this.mutablesData[0].mutableAttrVal;\n\n        // GET TRANSMISSION ELEMENTS DATA\n        this.asynPayload.transmissionElsData = {};\n        this.asynPayload = store.transmissionElsData(this.asynPayload, listenerType, 'modelVal');\n\n        // GET DEFERRED MODEL ACTIONS\n        this.asynPayload.deferredModelData = Deferred.deferredActionsData;\n\n        this.asynPayload.actionType = message.updateQueue[0].type;\n        this.actionType = this.asynPayload.actionType;\n        \n        this.asynPayload.isCustomEvent = message.updateQueue[0].isCustomEvent;\n        this.isCustomEvent = this.asynPayload.isCustomEvent;\n\n        this.asynPayload = JSON.stringify(this.asynPayload);\n\n\n        fetch(this.url, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'X-Requested-With': 'XMLHttpRequest',\n                'Accept': 'text/html, application/xhtml+xml',\n                'X-ASYNergy': true,\n\n                // SET CUSTOM HEADERS\n                ...(this.headers),\n\n                // WE'LL SET THIS EXPLICITLY TO MITIGATE POTENTIAL\n                // INTERFERENCE FROM AD-BLOCKERS/ETC.\n                'Referer': window.location.href\n            },\n            body: this.asynPayload\n        })   \n        .then(response => {\n            if (response.ok) {\n              store.callHook('element.updating', this.updateEl, message.agent, this.event);\n\n              response.text().then(response => {\n\n                const responseObj = JSON.parse(response);\n\n                Object.values(responseObj.asynergyResponse).forEach(respItem => {\n                  if (respItem.url !== undefined) {\n                    location = respItem.url;\n                    return;\n                  }\n\n                  if ((respItem.mutableVal === null) || (typeof(respItem.mutableVal) === \"object\") &&\n                  (Object.keys(respItem.mutableVal).length === 0)) {\n                    respItem.mutableVal = \"\";\n                  }\n\n                  this.updateEl.updated = 0;\n\n                  this.updateMutablesByID(respItem);\n                \n                  this.updateMutablesByAttrVal(respItem);\n\n                  if (this.updateEl.updated === 0) {\n                    this.updateEl.innerHTML = respItem.mutableVal;\n                  }\n                  \n                  store.callHook('element.updated', this.updateEl, message.agent, this.event);\n                \n                  this.syncModels(respItem);\n\n                  store.callHook('message.processed', this.updateEl, message.agent, this.event);\n                  \n                }); // Object.values(responseObj).forEach(respItem => {\n                \n\n              });\n            }\n        })\n        \n        .then(this.callback(this.updateEl))\n        \n        .catch((error) => {\n            console.error(\"Error:\", error);\n          });\n    }\n    \n    // IF THE RESPONSE INCLUDES IDs OF MUTABLE ELEMENTS\n    // UPDATE ALL APPROPRIATE ELEMENTS\n    updateMutablesByID (responseObj) {\n      if ((responseObj.mutableID !== \"\") && \n      (responseObj.mutableID !== null)) {\n        const mutableID = responseObj.mutableID;\n        \n        if (typeof(mutableID) === \"object\") {\n          Object.values(mutableID).forEach(theID => {\n            this.updateEl = document.getElementById(`${theID}`);\n\n            this.updateEl.nodeName === \"INPUT\" ? this.updateEl.value = responseObj.mutableVal : this.updateEl.innerHTML = responseObj.mutableVal;\n            this.updateEl.updated = 1;\n          });\n        } else {\n          this.updateEl = document.getElementById(`${mutableID}`);\n          this.updateEl.nodeName === \"INPUT\" ? this.updateEl.value = responseObj.mutableVal : this.updateEl.innerHTML = responseObj.mutableVal;\n\n          this.updateEl.updated = 1;\n        }\n      }\n    }\n\n    // IF MULTIPLE MUTABLE ELEMENTS ARE SPECIFIED BY MUTABLE\n    // ATTRIBUTE VALUES IN THE RESPONSE, UPDATE ALL MUTABLE\n    // ELEMENTS THAT HAVE THE APPROPRIATE MUTABLE ATTRIBUTE VALUE\n    updateMutablesByAttrVal(responseObj) {\n      if (responseObj.mutableAttrVal !== \"\") {\n        if (this.mutablesData.length > 0) {\n          let attrValFragments = [];\n          let attrValPrefix = '';\n          this.mutablesData.forEach(mutable => {\n            const compoundAttrVal = mutable.mutableAttrVal.search(/[.]/);\n            if (compoundAttrVal !== -1) {\n              attrValFragments = /^.+(?=(\\.))/.exec(mutable.mutableAttrVal);\n              attrValPrefix = attrValFragments[0];\n            }\n\n            if ((mutable.mutableAttrVal === responseObj.mutableAttrVal) || \n                (mutable.mutableAttrVal === attrValPrefix) || \n                (Object.values(responseObj.mutableAttrVal).indexOf(mutable.mutableAttrVal) > -1)) {\n              this.updateEl = mutable.el;\n\n              this.updateEl.nodeName === \"INPUT\" ? this.updateEl.value = responseObj.mutableVal : this.updateEl.innerHTML = responseObj.mutableVal;\n              this.updateEl.updated = 1;\n            }\n            \n          });\n        }\n      }\n    }\n    \n    // SYNCHRONIZE ANY MODEL TO THE DATA OF THE MUTABLE ELEMENT\n    syncModels(responseObj) {\n      if ((responseObj.syncModelID !== \"\") && \n      (responseObj.syncModelID !== null)) {\n        let modelID = responseObj.syncModelID;\n\n        if (this.actionType === \"syncInput\") {\n          // SYNCHRONIZING NEEDS A DELAY, OTHERWISE SOME INPUT MAY BE LOST\n          let timer;\n          const model = document.getElementById(`${modelID}`);\n          const mutableEl = this.updateEl;\n          const timeOut = this.modelSyncTimeout;\n\n          if (model.getAttribute('listener') !== 'true') {\n            model.value = mutableEl.innerHTML;\n          }\n\n          model.addEventListener(\"input\", function (e) {\n            model.setAttribute('listener', 'true');\n            clearTimeout(timer);\n            timer = setTimeout(() => {\n              model.value = mutableEl.innerHTML;\n              model.removeAttribute('listener');\n            }, timeOut);\n          });\n          \n        } else {\n          \n          const modelID = responseObj.syncModelID;\n          \n          // IF modelID IS AN OBJECT, THEN THERE ARE MULTIPLE OBJECTS TO BE SYNCED\n          if (typeof(modelID) === \"object\") {\n            Object.values(modelID).forEach(theID => {\n              document.getElementById(`${theID}`).value = responseObj.mutableVal;\n            });\n          } else {\n            // THERE IS ONLY ONE MODEL TO BE SYNCED\n            document.getElementById(`${modelID}`).value = responseObj.mutableVal; // ?????????????\n          }\n        }\n      }\n    }\n}\n","import { asynDirectives } from '../util/asynDirectives';\n\n/**\n * This is intended to isolate all native DOM operations. The operations that happen\n * one specific element will be instance methods, the operations you would normally\n * perform on the \"document\" (like \"document.querySelector\") will be static methods.\n */\nexport default {\n    allModelElementsInside(root) {\n        return Array.from(root.querySelectorAll(`[asyn\\\\:model]`));\n    },\n\n    getByAttributeAndValue(attribute, value) {\n        return document.querySelector(`[asyn\\\\:${attribute}=\"${value}\"]`);\n    },\n\n    hasAttribute(el, attribute) {\n        return el.hasAttribute(`asyn:${attribute}`);\n    },\n\n    getAttribute(el, attribute) {\n        return el.getAttribute(`asyn:${attribute}`);\n    },\n\n    removeAttribute(el, attribute) {\n        return el.removeAttribute(`asyn:${attribute}`);\n    },\n\n    setAttribute(el, attribute, value) {\n        return el.setAttribute(`asyn:${attribute}`, value);\n    },\n\n    hasFocus(el) {\n        return el === document.activeElement;\n    },\n\n    isInput(el) {\n        return ['INPUT', 'TEXTAREA', 'SELECT'].includes(\n            el.tagName.toUpperCase()\n        );\n    },\n\n    isTextInput(el) {\n        return (\n            ['INPUT', 'TEXTAREA'].includes(el.tagName.toUpperCase()) &&\n            !['checkbox', 'radio'].includes(el.type)\n  );\n    },\n\n    valueFromInput(el, agent) {\n        if (el.type === 'checkbox') {\n            let modelName = asynDirectives(el).get('model').value;\n            // If there is an update from asyn:model.defer in the chamber,\n            // we need to pretend that is the actual data from the server.\n            let modelValue = agent.deferredActions[modelName]\n                ? agent.deferredActions[modelName].asynPayload.value\n                // : get(agent.data, modelName);\n                : el.checked;\n\n            if (Array.isArray(modelValue)) {\n                return this.mergeCheckboxValueIntoArray(el, modelValue);\n            }\n\n            if (el.checked) {\n                return el.getAttribute('value') || true;\n            } else {\n                return false;\n            }\n        } else if (el.tagName === 'SELECT' && el.multiple) {\n            return this.getSelectValues(el);\n        }\n\n        return el.value;\n    },\n\n    mergeCheckboxValueIntoArray(el, arrayValue) {\n        if (el.checked) {\n            return arrayValue.includes(el.value)\n                ? arrayValue\n                : arrayValue.concat(el.value);\n        }\n\n        return arrayValue.filter(item => item != el.value);\n    },\n      \n      setInputValueFromModel(el, agent) {\n          const modelString = asynDirectives(el).get('model').value;\n          const modelValue = get(agent.data, modelString);\n\n          // Don't manually set file input's values.\n          if (\n              el.tagName.toLowerCase() === 'input' &&\n              el.type === 'file'\n          )\n              return;\n\n          this.setInputValue(el, modelValue);\n      },\n\n    setInputValue(el, value) {\n        if (el.type === 'radio') {\n            el.checked = el.value == value;\n        } else if (el.type === 'checkbox') {\n            if (Array.isArray(value)) {\n                // I'm purposely not using Array.includes here because it's\n                // strict, and because of Numeric/String mis-casting, I\n                // want the \"includes\" to be \"fuzzy\".\n                let valueFound = false;\n                value.forEach(val => {\n                    if (val == el.value) {\n                        valueFound = true;\n                    }\n                });\n\n                el.checked = valueFound;\n            } else {\n                el.checked = !!value;\n            }\n        } else if (el.tagName === 'SELECT') {\n            this.updateSelect(el, value);\n        } else {\n            value = value === undefined ? '' : value;\n\n            el.value = value;\n        }\n    },\n\n    getSelectValues(el) {\n        return Array.from(el.options)\n          .filter(option => option.selected)\n          .map(option => option.value || option.text);\n    },\n\n    updateSelect(el, value) {\n        const arrayWrappedValue = [].concat(value).map(value => value + '');\n\n        Array.from(el.options).forEach(option => {\n            option.selected = arrayWrappedValue.includes(option.value);\n        });\n    }\n};\n","import Action from '.';\n\nexport default class extends Action {\n    constructor(modelAttrVal, params, modelVal, isCustomEvent, el, skipWatcher = false) {\n        super(el, skipWatcher);\n\n        this.isCustomEvent = isCustomEvent;\n        this.type = 'callHandler';\n        this.name = modelAttrVal;\n        this.payload = {\n            modelAttrVal,\n            params,\n            modelVal\n        };\n    }\n\n}","import Action from '.';\n\nexport default class extends Action {\n    constructor(modelAttrVal, params, modelVal, isCustomEvent, el) {\n        super(el);\n\n        this.isCustomEvent = isCustomEvent;\n        this.type = 'syncInput';\n        this.name = modelAttrVal;\n        this.payload = {\n            // id: this.signature,\n            modelAttrVal,\n            params,\n            modelVal\n        };\n    }\n}\n","export default class {\n    constructor(agent, updateQueue) {\n        this.agent = agent;\n        this.updateQueue = updateQueue;\n    }\n\n    payload() {\n        return {\n            // This ensures only the type & payload properties only get sent over.\n            updates: this.updateQueue.map(update => ({\n                type: update.type,\n                payload: update.payload\n            }))\n        };\n    }\n}\n","import Message from '../Message';\nimport { debounce } from '../util/debounce';\nimport store from '../Store';\nimport DeferredModelAction from '../action/deferred-model';\nimport { walkDOM } from '../util/walkDOM';\nimport MessageBus from '../MessageBus';\n\nexport default class {\n    constructor(el, connection, postValue, agentID) {\n        this.el = el;\n        this.updateQueue = [];\n        this.deferredActions = {}; // temp test\n        this.messageInTransit = undefined;\n        this.connection = connection;\n        this.postValue = postValue;\n        this.agentID = agentID;\n        this.tearDownCallbacks = [];\n        this.scopedListeners = new MessageBus();\n        this.listeners = [];\n    }\n\n    on(event, callback) {\n      this.scopedListeners.register(event, callback);\n    }\n\n    addAction(action) {\n        if (action instanceof DeferredModelAction) {\n            this.deferredActions[action.name] = action;\n\n            return;\n        }\n\n        this.updateQueue.push(action);\n\n        // This debounce is here in-case two events fire at the \"same\" time:\n        // For example: if you are listening for a click on element A,\n        // and a \"blur\" on element B. If element B has focus, and then,\n        // you click on element A, the blur event will fire before the \"click\"\n        // event. This debounce captures them both in the actionsQueue and sends\n        // them off at the same time.\n        // Note: currently, it's set to 5ms, that might not be the right amount, we'll see.\n        debounce(this.fireMessage, 5).apply(this);\n\n        // Clear prefetches.\n        // this.prefetchManager.clearPrefetches()\n    }\n\n    fireMessage() {\n        Object.entries(this.deferredActions).forEach(([modelName, action]) => {\n          this.updateQueue.unshift(action);\n        });\n        this.deferredActions = {};\n\n        this.messageInTransit = new Message(this, this.updateQueue);\n\n      let sendMessage = () => {\n        this.connection.action(this.messageInTransit);\n\n        store.callHook('message.sent', this.messageInTransit, this);\n\n        this.updateQueue = [];\n      };\n        sendMessage();\n    }\n\n    walk(callback, callbackWhenNewComponentIsEncountered = el => { }) {\n      walkDOM(this.el, el => {\n        // Skip the root component element.\n        if (el.isSameNode(this.el)) {\n          callback(el);\n          return;\n        }\n\n        if (callback(el) === false) {\n          return false;\n        }\n      });\n    }\n\n    callAfterModelDebounce(callback) {\n        // This is to protect against the following scenario:\n        // A user is typing into a debounced input, and hits the enter key.\n        // If the enter key submits a form or something, the submission\n        // will happen BEFORE the model input finishes syncing because\n        // of the debounce. This makes sure to clear anything in the debounce queue.\n\n        if (this.modelDebounceCallbacks) {\n            this.modelDebounceCallbacks.forEach(callbackRegister => {\n                callbackRegister.callback();\n                callbackRegister.callback = () => { };\n            });\n        }\n\n      callback();\n    }\n\n    addListenerForTeardown(teardownCallback) {\n        this.tearDownCallbacks.push(teardownCallback);\n    }\n\n    tearDown() {\n        this.tearDownCallbacks.forEach(callback => callback());\n    }\n}\n","import { debounce } from './util/debounce';\nimport { kebabCase } from './util';\nimport { asynDirectives } from './util/asynDirectives';\nimport Connection from './connection/index';\nimport DOM from './dom/dom';\nimport HandlerAction from './action/handler';\nimport store from './Store';\nimport ModelAction from './action/model';\nimport DeferredModelAction from './action/deferred-model';\nimport Deferred from './action/Deferred';\nimport Agent from './agent/index';\n\nexport default {\n\n    initialize(el, url) {\n        let isAgent = false;\n        asynDirectives(el).all().forEach(directive => {\n            let test;\n            let lcFunc;\n            switch (directive.type) {\n\n            case 'model': {\n                if (!directive.value) {\n                    console.warn('ASYNergy: [asyn:model] is missing a value.', el);\n\n                    break;\n                }\n\n                // DOM.setInputValueFromModel(el, component)\n                // CHECK FOR COMPUND MODEL NAME, USE THE PREFIX TO CHECK\n                // IF THERE IS A CORRESPONDING MUTABLE ELEMENT\n                let directiveVal = '';\n                let compoundName = directive.value.search(/[.]/);\n                if (compoundName !== -1) {\n                    const dirValPrefix = /^.+(?=(\\.))/.exec(directive.value);\n                    directiveVal = dirValPrefix[0];\n                } else {\n                    directiveVal = directive.value;\n                }\n\t\t\t\t\t\t\t\n                // GET RID OF THE MODEL PARAMETERS\n                compoundAttrVal = directive.value.search(/[\\(]/);\n                \n                if (compoundAttrVal !== -1) {\n                  const dirVal = /^.+(?=(\\())/.exec(directive.value);\n                  directiveVal = dirVal[0];\n                }\n\n                let mutableElem = document.querySelector(`[asyn\\\\:mutable=${directiveVal}]`);\n\n                // GET ATTRIBUTE\n                let attr = this.modelAttr(directive.fullName, directiveVal);               \n                let modelElem = document.querySelector(`[${attr}]`);\n\n                if (mutableElem !== null) {\n                  this.attachModelListener(el, directive, mutableElem, url, modelElem, directiveVal);\n                } else {\n                    mutableElem = document.querySelector(`[asyn\\\\:mutable^=${directiveVal}\\\\.]`);\n                    if (mutableElem !== null) {\n                      this.attachModelListener(el, directive, mutableElem, url, modelElem, directiveVal);\n                    } else {\n                        console.warn(\n                        'ASYNergy: [asyn:model] is missing a corresponding [asyn:mutable] element.',\n                        el);\n                    }\n                }\n\n                test = 'model';\n                isAgent = true;\n                break;\n            }\n\n            case 'mutable':\n\n                lcFunc = directive.lcFunction;\n                store.mutables.push(directive);\n\n                test = 'mutable';\n                isAgent = false;\n                break;\n\n            case 'transmit':\n                // CHECK IF ELEMENT IS A MUTABLE ELEMENT, NEEDED TO\n                // REPLACE A MODEL CHECKBOX VALUE WITH THE MODEL INPUT VALUE\n                directive.el.mutable = el.getAttributeNames().indexOf('asyn:mutable');\n\n                store.transmissionEls.push(directive.el);\n\n                test = 'transmit';\n                isAgent = true;\n                break;\n\n            case 'csrf':\n                store.csrf.tokenName = directive.value;\n                store.csrf.token = el.value;\n\n                test = 'csrf';\n                isAgent = false;\n                break;\n\n            default:\n              const params = directive.params;\n              let handler = directive.value;\n              if (params.length !== 0) {\n                handler = directive.handler;\n              }\n\n                let mutableElem = document.querySelector(`[asyn\\\\:mutable=${handler}]`);\n                if (mutableElem === null) {\n                    mutableElem = document.querySelector(`[asyn\\\\:mutable^=${handler}\\\\.]`);\n                }\n\n                // GET ATTRIBUTE\n                let attr = this.modelAttr(directive.fullName, directive.value);\n                let modelElem = document.querySelector(`[${attr}]`);\n\n                if (store.directives.has(directive.type)) {\n                    store.directives.call(\n                      directive.type,\n                      el,\n                      directive,\n                      mutableElem,\n                      url\n                          );\n                }\n\n                this.attachDomListener(el, directive, mutableElem, url, modelElem);\n\n                test = 'default';\n                isAgent = true;\n                break;\n        }\n\n        });\n\n        if (isAgent === true) {\n            let index = store.agents.length - 1;\n            let theAgent = store.agents[index];\n            let eventType = theAgent.connection.event;\n            store.callHook('element.initialized', el, theAgent, eventType);\n        }\n        isAgent = false;\n    },\n\n    attachModelListener(el, directive, mutableEl, url, modelEl, modelAttrVal) {\n        const isLazy = directive.modifiers.includes('lazy');\n\n        const debounceIf = (condition, callback, time) =>\n          condition ? directive.modelSyncDebounce(callback, time) : callback;\n\n        const hasDebounceModifier = directive.modifiers.includes('debounce');\n\n      store.callHook('interceptAsynModelAttachListener', directive, el, mutableEl);\n\n        let event = el.tagName.toLowerCase() === 'select'\n        || ['checkbox', 'radio'].includes(el.type)\n        || directive.modifiers.includes('lazy') ? 'change' : 'input';\n        \n        if (el.tagName.toLowerCase() === 'input' && directive.modifiers.includes('blur')) {\n          event = 'blur';\n        }\n\n        let model = modelAttrVal;\n\n        // TODO check for trailing slashes\n        const handlerURL = url + '/' + model;\n      const initConnection = new Connection(handlerURL, mutableEl, model, modelEl, event);\n\n        const connect = {\n            sendMessage: function () {\n                // INPUT FIELD VALUE\n                let postValue = el.value;\n                initConnection.action(postValue);\n            }\n        };\n\n        let agentID = store.agents.length + 1;\n        let agent = store.addAgent(new Agent(el, initConnection, el.value, agentID));\n\n        if (directive.modifiers.includes('defer')) {\n            Deferred.addAction(directive.value, el.value, el);\n        }\n\n        // If it's a text input and not .lazy, debounce, otherwise fire immediately.\n        let handler = debounceIf(hasDebounceModifier || (DOM.isTextInput(el) && !isLazy), e => {\n            let model = directive.value;\n            let params = directive.params;\n            let el = e.target;\n\n            const isCustomEvent = e instanceof CustomEvent;\n\n            isCustomEvent ? directive.emitEvent = true : directive.emitEvent = false;\n\n            let modelVal = e instanceof CustomEvent\n                // We have to check for typeof e.detail here for IE 11.\n                && typeof e.detail != 'undefined'\n                && typeof window.document.documentMode == 'undefined'\n                    // With autofill in Safari, Safari triggers a custom event and assigns\n                    // the value to e.target.value, so we need to check for that value as well.\n                    ? e.detail || e.target.value\n                    : DOM.valueFromInput(el, agent);\n\n            if (directive.modifiers.includes('defer')) {\n                agent.addAction(new DeferredModelAction(model, params, modelVal, isCustomEvent, el));\n            } else {\n                agent.addAction(new ModelAction(model, params, modelVal, isCustomEvent, el));\n            }\n        }, directive.durationOr(150));\n\n        store.addEmitEvent(el, directive.params, directive.handler, handler);\n\n        el.addEventListener(event, handler);\n\n        agent.addListenerForTeardown(() => {\n          el.removeEventListener(event, handler);\n        });\n\n        // Taken from: https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser\n      let isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n\n        // Safari is weird and doesn't properly fire input events when\n        // a user \"autofills\" a asyn:model(.lazy) field. So we are\n        // firing them manually for assurance.\n      isSafari && el.addEventListener('animationstart', e => {\n        if (e.animationName !== 'asynergyAutofill') {\n          return;\n        }\n\n        e.target.dispatchEvent(new Event('change', { bubbles: true }));\n        e.target.dispatchEvent(new Event('input', { bubbles: true }));\n      });\n    },\n\n    attachDomListener(el, directive, mutableEl, url, modelEl) {\n        switch (directive.type) {\n        case 'keydown':\n        case 'keyup':\n\n            this.attachListener(el, directive, e => {\n                // Detect system modifier key combinations if specified.\n                const systemKeyModifiers = [\n                 'ctrl',\n                 'shift',\n                 'alt',\n                 'meta',\n                 'cmd',\n                 'super'\n                ];\n                const selectedSystemKeyModifiers = systemKeyModifiers.filter(\n                       key => directive.modifiers.includes(key)\n                   );\n\n                if (selectedSystemKeyModifiers.length > 0) {\n                    const selectedButNotPressedKeyModifiers = selectedSystemKeyModifiers.filter(\n                      key => {\n                                // Alias \"cmd\" and \"super\" to \"meta\"\n                                if (key === 'cmd' || key === 'super') {\n                                    key = 'meta';\n                                }\n                                return !e[`${key}Key`];\n                            }\n                       );\n\n                    if (selectedButNotPressedKeyModifiers.length > 0) {\n                        return false;\n                    }\n                }\n\n                // Handle spacebar\n                if (e.keyCode === 32 || (e.key === ' ' || e.key === 'Spacebar')) {\n                    return directive.modifiers.includes('space');\n                }\n\n                // Strip 'debounce' modifier and time modifiers from modifiers list\n                let modifiers = directive.modifiers.filter(modifier =>\n                        (\n                           !modifier.match(/^debounce$/) &&\n                           !modifier.match(/^[0-9]+m?s$/)\n                       )\n                   );\n\n                // Only handle listener if no, or matching key modifiers are passed.\n                // It's important to check that e.key exists - OnePassword's extension\n                // does weird things.\n                return Boolean(modifiers.length ===\n                  0 || (e.key && modifiers.includes(kebabCase(e.key))));\n            }, mutableEl, url, modelEl);\n\n            break;\n        case 'click':\n\n            this.attachListener(el, directive, e => {\n                // We only care about elements that have the .self modifier on them.\n                if (!directive.modifiers.includes('self')) {\n                    return;\n                }\n\n                // This ensures a listener is only run if the event originated\n                // on the elemenet that registered it (not children).\n                // This is useful for things like modal back-drop listeners.\n              return el.isSameNode(e.target);\n            }, mutableEl, url, modelEl);\n\n            break;\n        default:\n            this.attachListener(el, directive, e => el === e.target, mutableEl, url, modelEl);\n            break;\n    \t\t\t}\n    },\n\n    attachListener(el, directive, callback, mutableEl, url, modelEl) {\n        const event = directive.type;\n        const model = directive.handler;\n\n        // TODO check for trailing slashes\n        const handlerURL = url + '/' + model;\n\n        const initConnection = new Connection(handlerURL, mutableEl, model, modelEl, event);\n\n        let postValue = () => {\n            return el.value !== undefined ? el.value : el.innerText;\n        };\n\n        let agentID = store.agents.length + 1;\n        let agent = store.addAgent(new Agent(el, initConnection, postValue(), agentID));\n\n        const handler = e => {\n            if (callback && callback(e) === false) {\n                return;\n            }\n            \n            const isCustomEvent = e instanceof CustomEvent;\n\n          agent.callAfterModelDebounce(() => {\n            const el = e.target;\n\n            directive.setEventContext(e);\n\n            // This is outside the conditional below so \"asyn:click.prevent\"\n            // without a value still prevents default.\n            this.preventAndStop(e, directive.modifiers);\n            const handler = directive.handler;\n            let params = directive.params;\n            let modelVal = directive.modelValue;\n\n            if (isCustomEvent) {\n              directive.emitEvent = true;\n              if (e.detail !== undefined) {\n                modelVal = e.detail;\n              }\n            } else {\n              directive.emitEvent = false;\n            }\n\n            if (\n              params.length === 0 &&\n              isCustomEvent &&\n              e.detail\n            ) {\n              params.push(e.detail);\n            }\n\n            if (directive.value) {\n              agent.addAction(new HandlerAction(handler, params, modelVal, isCustomEvent, el));\n            }\n\n          });\n        };\n\n        const debounceIf = (condition, callback, time) =>\n          condition ? debounce(callback, time) : callback;\n\n        const hasDebounceModifier = directive.modifiers.includes('debounce');\n        const debouncedHandler = debounceIf(\n           hasDebounceModifier,\n           handler,\n           directive.durationOr(150)\n        );\n\n        store.addEmitEvent(el, directive.params, directive.handler, handler);\n\n        el.addEventListener(event, debouncedHandler);\n\n        agent.addListenerForTeardown(() => {\n          el.removeEventListener(event, debouncedHandler);\n        });\n    },\n    \n    preventAndStop(event, modifiers) {\n      modifiers.includes('prevent') && event.preventDefault();\n      modifiers.includes('stop') && event.stopPropagation();\n    },\n\n    modelAttr(fullName, attrVal) {\n      let escFullName = this.escapedStr(fullName);\n      let escAttrVal = this.escapedStr(attrVal);\n      let attr = escFullName + \"=\" + \"\\\"\" + escAttrVal + \"\\\"\";\n      return attr;\n    },\n    \n    escapedStr(str) {\n      let escapedStr = str;\n      escapedStr = escapedStr.replace(/\\:|\\.|\"|'/gi, function (x) {\n        return \"\\\\\" + x;\n      });\n      return escapedStr;\n    }\n};\n","\nexport * from './debounce';\nexport * from './asynDirectives';\nexport * from './walkDOM';\n\nexport function kebabCase(subject) {\n    return subject.replace(/([a-z])([A-Z])/g, '$1-$2').replace(/[_\\s]/, '-').toLowerCase();\n}\n\nexport function tap(output, callback) {\n    callback(output);\n\n    return output;\n}\n","import store from '../Store';\nimport { asynDirectives } from '../util/asynDirectives';\n\nlet cleanupStackByAgentId = {};\n\nexport default function () {\n  store.registerHook('element.initialized', (el, agent) => {\n    let directives = asynDirectives(el);\n\n    if (directives.missing('submit')) return;\n\n    // Set a forms \"disabled\" state on inputs and buttons.\n    // ASYNergy will clean it all up automatically submitting the form.\n    el.addEventListener('submit', () => {\n      cleanupStackByAgentId[agent.agentID] = [];\n\n      agent.walk(node => {\n        if (!el.contains(node)) return;\n\n        if (node.hasAttribute('asyn:ignore')) return false;\n\n        if (\n          // <button type=\"submit\">\n          (node.tagName.toLowerCase() === 'button' &&\n            node.type === 'submit') ||\n          // <select>\n          node.tagName.toLowerCase() === 'select' ||\n          // <input type=\"checkbox|radio\">\n          (node.tagName.toLowerCase() === 'input' &&\n            (node.type === 'checkbox' || node.type === 'radio'))\n        ) {\n\n          if (!node.disabled)\n            cleanupStackByAgentId[agent.agentID].push(\n              () => (node.disabled = false)\n            );\n\n          node.disabled = true;\n          // TODO: add node to disabled nodes array ---------------------------\n          store.addDisabledNode(node);\n        } else if (\n          // <input type=\"text\">\n          node.tagName.toLowerCase() === 'input' ||\n          // <textarea>\n          node.tagName.toLowerCase() === 'textarea'\n        ) {\n          if (!node.readOnly)\n            cleanupStackByAgentId[agent.agentID].push(\n              () => (node.readOnly = false)\n            );\n\n          node.readOnly = true;\n          // TODO: add node to readOnly nodes array ---------------------------\n          store.addReadOnlyNode(node);\n        }\n      });\n    });\n  });\n\n  store.registerHook('message.failed', (message, agent) => cleanup(agent));\n  store.registerHook('message.received', (message, agent) => cleanup(agent));\n}\n\nfunction cleanup(agent) {\n    if (!cleanupStackByAgentId[agent.agentID]) return;\n\n    while (cleanupStackByAgentId[agent.agentID].length > 0) {\n      cleanupStackByAgentId[agent.agentID].shift()();\n    }\n}\n","/*!\n* ASYNergy\n*\n* revIgniter JavaScript application *\n* inspired by and adopted from Livewire *\n* a framework for making network requests *\n* and changing things on the page *\n* Version 0.1.0 *\n*\n* Author: Ralf Bitter, rabit@revigniter.com\n*\n*/\n\n\nimport { walkDOM } from './util/walkDOM';\nimport nodeInitializer from './init_tasks';\nimport store from './Store';\nimport Polling from './agent/Polling';\nimport DisableForms from './agent/DisableForms';\nimport LoadingStates from './agent/LoadingStates';\n\nclass ASYNergy {\n    constructor() {\n      this.appVersion = '1.0.0';\n      this.agents = store;\n      this.URL = '';\n    }\n\n    get version() {\n        return this.appVersion;\n    }\n  \n  set theURL(url) {\n    this.URL = url;\n  }\n\n  get theURL() {\n    return this.URL;\n  }\n\n    hook(name, callback) {\n      this.agents.registerHook(name, callback);\n    }\n\n    emit(event, ...params) {\n      this.agents.emit(event, ...params);\n    }\n\n    on(event, callback) {\n      this.agents.on(event, callback);\n    }\n\n    stop() {\n        this.agents.tearDownAgents();\n    }\n\n    start() {\n        // TODO check forms and handlerURL in init_tasks.js\n      const URL = this.URL !== '' ? this.URL : window.location.href;\n\n        const callBackFn = (el) => {\n            nodeInitializer.initialize(el, URL);\n        };\n\n        const bodyEl = document.body;\n\n        document.addEventListener(\n            'visibilitychange',\n            () => {\n              store.asynergyIsInBackground = document.hidden;\n            },\n            false\n        );\n\n        window.addEventListener('offline', () => {\n            store.asynergyIsOffline = true;\n        });\n\n        window.addEventListener('online', () => {\n            store.asynergyIsOffline = false;\n        });\n\n        walkDOM(bodyEl, callBackFn);\n    }\n}\n\nif (!window.ASYNergy) {\n    window.ASYNergy = ASYNergy;\n}\n\nLoadingStates();\nDisableForms();\nPolling();\n\n\nexport default ASYNergy;\n","import store from '../Store';\nimport { asynDirectives } from '../util/asynDirectives';\n\nexport default function () {\n    store.registerHook('agent.initialized', agent => {\n      agent.targetedLoadingElsByAction = {};\n      agent.genericLoadingEls = [];\n      agent.currentlyActiveLoadingEls = [];\n      agent.currentlyActiveUploadLoadingEls = [];\n    });\n\n    store.registerHook('element.initialized', (el, agent) => {\n      let directives = asynDirectives(el);\n\n        if (directives.missing('loading')) return;\n\n        const loadingDirectives = directives.directives.filter(\n            i => i.type === 'loading'\n        );\n    });\n\n\n    store.registerHook('message.sent', (message, agent) => {\n        const actions = message.updateQueue\n            .filter(action => {\n              return action.type === 'callHandler';\n            })\n            .map(action => action.payload.modelAttrVal);\n\n        const actionsWithParams = message.updateQueue\n            .filter(action => {\n              return action.type === 'callHandler';\n            })\n            .map(action =>\n                generateSignatureFromHandlerAndParams(\n                  action.payload.modelAttrVal,\n                    action.payload.params\n                )\n            );\n\n      const models = message.updateQueue\n        .filter(action => {\n          return action.type === 'syncInput';\n        })\n        .map(action => {\n          let name = action.payload.modelAttrVal;\n          if (!name.includes('.')) {\n            return name;\n          }\n\n          let modelActions = [];\n\n          modelActions.push(\n            name.split('.').reduce((fullAction, part) => {\n              modelActions.push(fullAction);\n\n              return fullAction + '.' + part;\n            })\n          );\n\n          return modelActions;\n        })\n        .flat();\n    });\n}\n\nexport function setUploadLoading(agent, modelName) {\n    const actionTargetedEls =\n  agent.targetedLoadingElsByAction[modelName] || [];\n\n  const allEls = removeDuplicates(agent.genericLoadingEls.concat(actionTargetedEls));\n\n  startLoading(allEls);\n\n  agent.currentlyActiveUploadLoadingEls = allEls;\n}\n\n\nexport function unsetUploadLoading(agent) {\n  endLoading(agent.currentlyActiveUploadLoadingEls);\n\n  agent.currentlyActiveUploadLoadingEls = [];\n}\n\n\nfunction startLoading(els) {\n    els.forEach(({ el, directive }) => {\n        if (directive.modifiers.includes('class')) {\n          let classes = directive.value.split(' ').filter(Boolean);\n\n            doAndSetCallbackOnElToUndo(\n                el,\n                directive,\n                () => el.classList.add(...classes),\n                () => el.classList.remove(...classes)\n            );\n        } else if (directive.modifiers.includes('attr')) {\n            doAndSetCallbackOnElToUndo(\n                el,\n                directive,\n                () => el.setAttribute(directive.value, true),\n                () => el.removeAttribute(directive.value)\n            );\n        } else {\n            let cache = window\n                .getComputedStyle(el, null)\n          .getPropertyValue('display');\n\n            doAndSetCallbackOnElToUndo(\n                el,\n                directive,\n                () => {\n                  el.style.display = directive.modifiers.includes('remove')\n                    ? cache\n                    : getDisplayProperty(directive);\n                },\n                () => {\n                  el.style.display = 'none';\n                }\n            );\n        }\n    });\n}\n\n\nfunction getDisplayProperty(directive) {\n    return (['inline', 'block', 'table', 'flex', 'grid', 'inline-flex']\n  .filter(i => directive.modifiers.includes(i))[0] || 'inline-block');\n}\n\n\nfunction doAndSetCallbackOnElToUndo(el, directive, doCallback, undoCallback) {\n  if (directive.modifiers.includes('remove'))\n    [doCallback, undoCallback] = [undoCallback, doCallback];\n\n    if (directive.modifiers.includes('delay')) {\n      let duration = 200;\n\n        let delayModifiers = {\n            'shortest': 50,\n            'shorter': 100,\n            'short': 150,\n            'long': 300,\n            'longer': 500,\n            'longest': 1000,\n        };\n\n        Object.keys(delayModifiers).some(key => {\n            if(directive.modifiers.includes(key)) {\n              duration = delayModifiers[key];\n              return true;\n            }\n        });\n\n      let timeout = setTimeout(() => {\n        doCallback();\n        el.__asynergy_on_finish_loading.push(() => undoCallback());\n      }, duration);\n\n      el.__asynergy_on_finish_loading.push(() => clearTimeout(timeout));\n    } else {\n      doCallback();\n      el.__asynergy_on_finish_loading.push(() => undoCallback());\n    }\n}\n\n\nfunction endLoading(els) {\n  els.forEach(({ el }) => {\n    while (el.__asynergy_on_finish_loading.length > 0) {\n      el.__asynergy_on_finish_loading.shift()();\n    }\n  });\n}\n\n\nfunction generateSignatureFromHandlerAndParams(handler, params) {\n  return handler + btoa(encodeURIComponent(handler.toString()));\n}\n\n\nfunction removeDuplicates(arr) {\n  return Array.from(new Set(arr));\n}\n","import HandlerAction from '../action/handler';\nimport { asynDirectives } from '../util/asynDirectives';\nimport store from '../Store';\n\nexport default function () {\n    store.registerHook('element.initialized', (el, agent) => {\n        let directive = asynDirectives(el).get('poll');\n\n        if (directive === undefined) {\n            return;\n        }\n\n        let intervalId = fireActionOnInterval(el, agent);\n\n        agent.addListenerForTeardown(() => {\n          clearInterval(intervalId);\n        });\n\n        el.__asynergy_polling_interval = intervalId;\n    });\n}\n\nfunction fireActionOnInterval(node, agent) {\n    let interval = asynDirectives(node).get('poll').durationOr(2000);\n\n    return setInterval(() => {\n        if (node.isConnected === false) {\n            return;\n        }\n\n        const directive = asynDirectives(node).get('poll');\n\n        if (directive === undefined) {\n            return;\n        }\n\n        const handler = directive.handler || 'refresh';\n\n        // Don't poll when the tab is in the background.\n        // (unless the \"asyn:poll.keep-alive\" modifier is attached)\n        if (store.asynergyIsInBackground && !directive.modifiers.includes('keep-alive')) {\n            // This \"Math.random\" business effectivlly prevents 95% of requests\n            // from executing. We still want \"some\" requests to get through.\n            if (Math.random() < .95) {\n                return;\n            }\n        }\n\n        // Only poll visible elements. Visible elements are elements that\n        // are visible in the current viewport.\n        if (directive.modifiers.includes('visible') && !inViewport(directive.el)) {\n            return;\n        }\n\n        // Don't poll if asynergy is offline as well.\n        if (store.asynergyIsOffline) {\n            return;\n        }\n        agent.addAction(new HandlerAction(handler, directive.params, directive.modelValue, directive.emitEvent, node));\n    }, interval);\n}\n\nfunction inViewport(el) {\n    var bounding = el.getBoundingClientRect();\n\n    return (\n        bounding.top < (window.innerHeight || document.documentElement.clientHeight) &&\n        bounding.left < (window.innerWidth || document.documentElement.clientWidth) &&\n        bounding.bottom > 0 &&\n        bounding.right > 0\n    );\n}\n"]}